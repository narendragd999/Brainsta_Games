window.levelsData = [
  {
    "width": 1,
    "height": 1,
    "islands": [
      {
        "x": 0.22,
        "y": 0.5,
        "n": 1
      },
      {
        "x": 0.78,
        "y": 0.5,
        "n": 1
      }
    ]
  },
  {
    "width": 1,
    "height": 1,
    "islands": [
      {
        "x": 0.15,
        "y": 0.5,
        "n": 1
      },
      {
        "x": 0.5,
        "y": 0.5,
        "n": 2
      },
      {
        "x": 0.85,
        "y": 0.5,
        "n": 1
      }
    ]
  },
  {
    "width": 1,
    "height": 1,
    "islands": [
      {
        "x": 0.3,
        "y": 0.3,
        "n": 2
      },
      {
        "x": 0.7,
        "y": 0.3,
        "n": 1
      },
      {
        "x": 0.3,
        "y": 0.7,
        "n": 1
      },
      {
        "x": 0.7,
        "y": 0.7,
        "n": 2
      }
    ]
  },
  {
    "width": 1,
    "height": 1,
    "islands": [
      {
        "x": 0.2,
        "y": 0.25,
        "n": 1
      },
      {
        "x": 0.5,
        "y": 0.2,
        "n": 2
      },
      {
        "x": 0.8,
        "y": 0.25,
        "n": 1
      },
      {
        "x": 0.35,
        "y": 0.6,
        "n": 2
      },
      {
        "x": 0.65,
        "y": 0.6,
        "n": 2
      }
    ]
  },
  {
    "width": 1,
    "height": 1,
    "islands": [
      {
        "x": 0.18,
        "y": 0.25,
        "n": 1
      },
      {
        "x": 0.18,
        "y": 0.6,
        "n": 2
      },
      {
        "x": 0.42,
        "y": 0.4,
        "n": 3
      },
      {
        "x": 0.68,
        "y": 0.28,
        "n": 1
      },
      {
        "x": 0.82,
        "y": 0.6,
        "n": 2
      }
    ]
  },
  {
    "width": 1,
    "height": 1,
    "islands": [
      {
        "x": 0.12,
        "y": 0.3,
        "n": 2
      },
      {
        "x": 0.32,
        "y": 0.2,
        "n": 1
      },
      {
        "x": 0.5,
        "y": 0.35,
        "n": 3
      },
      {
        "x": 0.72,
        "y": 0.2,
        "n": 1
      },
      {
        "x": 0.88,
        "y": 0.35,
        "n": 2
      },
      {
        "x": 0.5,
        "y": 0.7,
        "n": 2
      }
    ]
  },
  {
    "width": 1,
    "height": 1,
    "islands": [
      {
        "x": 0.15,
        "y": 0.2,
        "n": 1
      },
      {
        "x": 0.15,
        "y": 0.5,
        "n": 2
      },
      {
        "x": 0.15,
        "y": 0.8,
        "n": 1
      },
      {
        "x": 0.5,
        "y": 0.35,
        "n": 3
      },
      {
        "x": 0.85,
        "y": 0.2,
        "n": 1
      },
      {
        "x": 0.85,
        "y": 0.5,
        "n": 2
      },
      {
        "x": 0.85,
        "y": 0.8,
        "n": 1
      }
    ]
  },
  {
    "width": 1,
    "height": 1,
    "islands": [
      {
        "x": 0.2,
        "y": 0.25,
        "n": 2
      },
      {
        "x": 0.4,
        "y": 0.15,
        "n": 1
      },
      {
        "x": 0.6,
        "y": 0.15,
        "n": 1
      },
      {
        "x": 0.8,
        "y": 0.25,
        "n": 2
      },
      {
        "x": 0.4,
        "y": 0.7,
        "n": 2
      },
      {
        "x": 0.6,
        "y": 0.7,
        "n": 2
      }
    ]
  },
  {
    "width": 1,
    "height": 1,
    "islands": [
      {
        "x": 0.12,
        "y": 0.2,
        "n": 1
      },
      {
        "x": 0.12,
        "y": 0.5,
        "n": 2
      },
      {
        "x": 0.12,
        "y": 0.8,
        "n": 1
      },
      {
        "x": 0.5,
        "y": 0.15,
        "n": 1
      },
      {
        "x": 0.5,
        "y": 0.5,
        "n": 4
      },
      {
        "x": 0.5,
        "y": 0.85,
        "n": 1
      },
      {
        "x": 0.88,
        "y": 0.2,
        "n": 1
      },
      {
        "x": 0.88,
        "y": 0.5,
        "n": 2
      },
      {
        "x": 0.88,
        "y": 0.8,
        "n": 1
      }
    ]
  },
  {
    "width": 1,
    "height": 1,
    "islands": [
      {
        "x": 0.22,
        "y": 0.18,
        "n": 1
      },
      {
        "x": 0.45,
        "y": 0.25,
        "n": 2
      },
      {
        "x": 0.7,
        "y": 0.18,
        "n": 1
      },
      {
        "x": 0.18,
        "y": 0.55,
        "n": 2
      },
      {
        "x": 0.4,
        "y": 0.5,
        "n": 3
      },
      {
        "x": 0.62,
        "y": 0.55,
        "n": 2
      },
      {
        "x": 0.85,
        "y": 0.5,
        "n": 1
      },
      {
        "x": 0.5,
        "y": 0.82,
        "n": 2
      }
    ]
  }
];

/* main.js â€” Hashi Bridges playable logic */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', { alpha: true });
let DPR = window.devicePixelRatio || 1;

const levels = window.levelsData;
let levelIndex = 0;
let currentLevel = null;

const state = {
  islands: [],
  bridges: [], // {a,b,count,segments: [{x1,y1,x2,y2}]}
  dragging: null,
  hover: null
};

// sizing helpers
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  draw();
}
window.addEventListener('resize', ()=>{ DPR = window.devicePixelRatio || 1; resizeCanvas(); });

// load level
function loadLevel(i){
  const raw = levels[i];
  state.islands = raw.islands.map((iv, idx)=>({
    id: idx,
    x: iv.x, y: iv.y, req: iv.n, cur:0
  }));
  state.bridges = [];
  // prebuild adjacency for faster checks
  state.width = raw.width; state.height = raw.height;
  draw();
  document.getElementById('levelNum').textContent = (i+1);
  playSound('level');
}
function start(){
  resizeCanvas();
  loadLevel(levelIndex);
}
start();

// convert normalized coords (0..1) to canvas pixels
function toPx(p){
  const w = canvas.width, h = canvas.height;
  return {x: Math.round(p.x * w), y: Math.round(p.y * h)};
}
function fromNorm(nx, ny){
  return {x: Math.round(nx * canvas.width), y: Math.round(ny * canvas.height)};
}

// utilities
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}

// find island under pointer
function findIslandAt(pos, radius=28){
  for(let isl of state.islands){
    const p = {x: isl.x*canvas.width, y: isl.y*canvas.height};
    if(dist(p,pos) <= radius * DPR) return isl;
  }
  return null;
}

/* BRIDGE LOGIC
 - Bridges only horizontal or vertical.
 - Max 2 bridges between same island pair.
 - Bridges can't cross other bridges.
 - Island's current count must match requirement at finish.
*/

// helper: check if two segments intersect (excluding touching at endpoints)
function segmentsIntersect(a1,a2,b1,b2){
  const EPS = 1e-6;
  function ccw(A,B,C){ return (C.y-A.y)*(B.x-A.x) > (B.y-A.y)*(C.x-A.x); }
  return (ccw(a1,b1,b2) !== ccw(a2,b1,b2)) && (ccw(a1,a2,b1) !== ccw(a1,a2,b2));
}

function canPlaceBridge(a,b){
  // allow only straight horizontal or vertical
  const ax = a.x*canvas.width, ay = a.y*canvas.height;
  const bx = b.x*canvas.width, by = b.y*canvas.height;
  if(!(Math.abs(ax-bx) < 10 || Math.abs(ay-by) < 10)) return false;
  // check existing bridge count between same pair
  const pair = state.bridges.find(br => (br.a===a.id && br.b===b.id) || (br.a===b.id && br.b===a.id));
  if(pair && pair.count >=2) return false;
  // build segment(s) for this new bridge: single line between centers, but we check collision with other bridges
  const seg = {x1:ax,y1:ay,x2:bx,y2:by};
  for(let br of state.bridges){
    // check each existing segment of other bridges for intersection
    for(let s of br.segments){
      if(segmentsIntersect({x:seg.x1,y:seg.y1},{x:seg.x2,y:seg.y2},{x:s.x1,y:s.y1},{x:s.x2,y:s.y2})){
        return false;
      }
    }
  }
  return true;
}

function placeBridge(a,b){
  if(a.id === b.id) return false;
  if(!canPlaceBridge(a,b)) return false;
  // find or create pair
  let pair = state.bridges.find(br => (br.a===a.id && br.b===b.id) || (br.a===b.id && br.b===a.id));
  if(!pair){
    pair = {a:a.id, b:b.id, count:0, segments:[]};
    state.bridges.push(pair);
  }
  // create segment (we offset second bridge slightly to show double)
  const ax = a.x*canvas.width, ay = a.y*canvas.height;
  const bx = b.x*canvas.width, by = b.y*canvas.height;
  const horiz = Math.abs(ay-by) < 10;
  const offset = (pair.count===0)?0: (horiz? 8 : 8);
  // offset perpendicular
  const dx = (horiz? 0 : offset);
  const dy = (horiz? offset : 0);
  pair.segments.push({x1:ax+dx,y1:ay+dy,x2:bx+dx,y2:by+dy});
  pair.count++;
  // update island counts
  state.islands.find(ix=>ix.id===pair.a).cur++;
  state.islands.find(ix=>ix.id===pair.b).cur++;
  animatePulse(a);
  animatePulse(b);
  playSound('place');
  checkCompletion();
  draw();
  return true;
}

function removeLastBridgeBetween(a,b){
  const pair = state.bridges.find(br => (br.a===a.id && br.b===b.id) || (br.a===b.id && br.b===a.id));
  if(!pair) return false;
  const seg = pair.segments.pop();
  pair.count--;
  state.islands.find(ix=>ix.id===pair.a).cur--;
  state.islands.find(ix=>ix.id===pair.b).cur--;
  if(pair.count===0){
    state.bridges = state.bridges.filter(br => br !== pair);
  }
  playSound('remove');
  draw();
  return true;
}

/* Interaction */
let pointerDown = false;
let startIsland = null;

canvas.addEventListener('pointerdown', (ev)=>{
  ev.preventDefault();
  const r = canvas.getBoundingClientRect();
  const pos = {x: (ev.clientX - r.left) * DPR, y: (ev.clientY - r.top) * DPR};
  pointerDown = true;
  const isl = findIslandAt(pos, 30);
  if(isl){
    startIsland = isl;
  } else {
    startIsland = null;
  }
});

canvas.addEventListener('pointerup', (ev)=>{
  const r = canvas.getBoundingClientRect();
  const pos = {x: (ev.clientX - r.left) * DPR, y: (ev.clientY - r.top) * DPR};
  pointerDown = false;
  if(startIsland){
    const end = findIslandAt(pos, 30);
    if(end){
      // if same pair and existing, remove last (toggle)
      const pair = state.bridges.find(br => (br.a===startIsland.id && br.b===end.id) || (br.a===end.id && br.b===startIsland.id));
      if(pair && pair.count>0){
        // if line exists, then add or remove? We'll toggle: if less than 2, add; otherwise remove last.
        if(pair.count < 2 && canPlaceBridge(startIsland,end)){
          placeBridge(startIsland,end);
        } else {
          removeLastBridgeBetween(startIsland,end);
        }
      } else {
        placeBridge(startIsland,end);
      }
    }
  }
  startIsland = null;
});

canvas.addEventListener('pointermove', (ev)=>{
  const r = canvas.getBoundingClientRect();
  const pos = {x: (ev.clientX - r.left) * DPR, y: (ev.clientY - r.top) * DPR};
  state.hover = findIslandAt(pos, 30);
  draw();
});

/* Drawing */
const pulseSet = new Set();
function animatePulse(isl){
  isl._pulse = 1.6;
  pulseSet.add(isl.id);
  window.requestAnimationFrame(()=>fadePulse(isl));
}
function fadePulse(isl){
  isl._pulse = (isl._pulse || 1.6) - 0.06;
  if(isl._pulse > 1.02){
    window.requestAnimationFrame(()=>fadePulse(isl));
  } else {
    isl._pulse = null;
    pulseSet.delete(isl.id);
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background subtle grid
  drawGrid();
  // draw bridges
  for(let br of state.bridges){
    for(let s of br.segments){
      drawBridgeSegment(s, br.count);
    }
  }
  // draw islands
  for(let isl of state.islands){
    drawIsland(isl);
  }
}

function drawGrid(){
  // subtle vignette
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,'rgba(255,255,255,0.02)');
  g.addColorStop(1,'rgba(0,0,0,0.02)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

function drawBridgeSegment(s, count){
  ctx.save();
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  // main line
  ctx.globalAlpha = 0.95;
  ctx.lineWidth = 6 * DPR;
  ctx.strokeStyle = '#2c3e50';
  ctx.beginPath();
  ctx.moveTo(s.x1, s.y1);
  ctx.lineTo(s.x2, s.y2);
  ctx.stroke();
  // inner highlight
  ctx.lineWidth = 3 * DPR;
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.beginPath();
  ctx.moveTo(s.x1, s.y1);
  ctx.lineTo(s.x2, s.y2);
  ctx.stroke();
  ctx.restore();
}

function drawIsland(isl){
  const x = Math.round(isl.x * canvas.width);
  const y = Math.round(isl.y * canvas.height);
  const r = Math.round(30 * DPR * (isl._pulse? isl._pulse : 1));
  // outer ring
  ctx.save();
  ctx.beginPath();
  ctx.fillStyle = 'white';
  roundRect(ctx, x- r, y - r, r*2, r*2, r*0.3);
  ctx.fill();
  // inner number circle
  ctx.beginPath();
  ctx.fillStyle = '#f7f9fb';
  ctx.arc(x,y,22*DPR,0,Math.PI*2);
  ctx.fill();
  // number
  ctx.fillStyle = '#222';
  ctx.font = `${18*DPR}px Inter, Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(isl.req, x, y);
  // current small indicator
  if(isl.cur > 0){
    ctx.fillStyle = '#3498db';
    ctx.font = `${12*DPR}px Inter, Arial`;
    ctx.fillText(isl.cur, x, y+28*DPR);
  }
  // highlight on hover
  if(state.hover && state.hover.id === isl.id){
    ctx.strokeStyle = 'rgba(52,152,219,0.9)';
    ctx.lineWidth = 3*DPR;
    ctx.beginPath();
    ctx.arc(x,y,26*DPR,0,Math.PI*2);
    ctx.stroke();
  }
  ctx.restore();
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* Level completion check */
function checkCompletion(){
  // all islands cur === req
  const all = state.islands.every(isl => isl.cur === isl.req);
  if(all){
    // slight delay then show modal
    playSound('win');
    showModal("Level Complete","Nice work â€” all bridges placed!");
  }
}

/* modal controls */
const overlay = document.getElementById('overlay');
function showModal(title,text){
  document.getElementById('modalTitle').textContent = title;
  document.getElementById('modalText').textContent = text;
  overlay.classList.remove('hidden');
}
document.getElementById('modalClose').addEventListener('click', ()=>overlay.classList.add('hidden'));
document.getElementById('modalNext').addEventListener('click', ()=>{ overlay.classList.add('hidden'); nextLevel(); });

/* buttons */
document.getElementById('nextBtn').addEventListener('click', nextLevel);
document.getElementById('prevBtn').addEventListener('click', prevLevel);
document.getElementById('resetBtn').addEventListener('click', ()=>loadLevel(levelIndex));
document.getElementById('hintBtn').addEventListener('click', ()=>giveHint());

function nextLevel(){
  levelIndex = Math.min(levels.length-1, levelIndex+1);
  loadLevel(levelIndex);
}
function prevLevel(){
  levelIndex = Math.max(0, levelIndex-1);
  loadLevel(levelIndex);
}

/* Simple hint: highlight an island with remaining requirement */
function giveHint(){
  const rem = state.islands.find(isl => isl.cur < isl.req);
  if(rem){
    animatePulse(rem);
    playSound('hint');
  }
}

/* Audio: using WebAudio for generated sounds */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playBeep(freq=440, dur=0.08, type='sine'){
  try{
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + dur + 0.02);
  }catch(e){ /* ignore */ }
}

function playSound(name){
  if(!audioCtx) return;
  switch(name){
    case 'place': playBeep(640,0.08,'sine'); break;
    case 'remove': playBeep(300,0.06,'sine'); break;
    case 'win': playBeep(880,0.18,'triangle'); break;
    case 'hint': playBeep(520,0.08,'sine'); break;
    case 'level': playBeep(440,0.09,'sine'); break;
    default: playBeep(440,0.05,'sine');
  }
}

/* load levels from window.levelsData (injected via levels.json inline by server) */
// We'll wire levelsData via a dynamic injection at top. If not present, attempt to fetch levels.json
if(!window.levelsData){
  fetch('levels.json').then(r=>r.json()).then(j=>{ window.levelsData=j; start(); }).catch(()=>{ console.error('levels load failed');});
}

/* initialize drawing loop to keep UI responsive */
function loop(){
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
