<!doctype html>
<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Scooter Runner - Smooth</title>
<style>
html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#b3e5fc;overflow:hidden;}
#gameCanvas{display:block;margin:0 auto;background:#87CEEB;width:100%;height:100vh;}
#hud{position:fixed;left:12px;top:12px;z-index:40;color:#fff;font-weight:bold;text-shadow:1px 1px 2px #000;}
#instructions{position:fixed;left:50%;transform:translateX(-50%);top:18px;color:#fff;font-weight:bold;z-index:40;text-shadow:1px 1px 2px #000;}
#touchbar{position:fixed;left:50%;transform:translateX(-50%);bottom:46px;width:70%;height:22px;background:rgba(0,0,0,0.25);border-radius:12px;z-index:40;}
#thumb{position:absolute;top:-7px;width:36px;height:36px;border-radius:50%;background:#fbf3b2;border:3px solid #222;right:0;box-shadow:0 4px 8px rgba(0,0,0,0.4);}
</style>
</head><body>
<div id="hud">Score: <span id="score">0</span></div>
<div id="instructions">HOLD AND SWIPE TO MOVE</div>
<div id="touchbar"><div id="thumb"></div></div>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width = window.innerWidth;
let H = canvas.height = window.innerHeight;
window.addEventListener('resize', ()=>{W=canvas.width=window.innerWidth;H=canvas.height=window.innerHeight;});

const assets = {};
function loadAssets(done){
  const list = [
    {name:'scooter', src:'assets/scooter_hd.png'},
    {name:'truck', src:'assets/truck_hd.png'},
    {name:'car', src:'assets/car_hd.png'},
    {name:'palm', src:'assets/palm_hd.png'},
    {name:'bg', src:'assets/bg_hd.png'},
    {name:'road', src:'assets/road_hd.png'}
  ];
  let loaded=0;
  list.forEach(it=>{
    const img=new Image();
    img.onload = ()=>{ assets[it.name]=img; loaded++; if(loaded===list.length) done(); };
    img.src = it.src;
  });
}

let lanes = 3;
let player = { lane:1, x:0, y:0, width:160, height:160, targetLane:1, lerpX:0 };
let obstacles = [];
let spawnTimer = 0;
let score = 0;
let speed = 7;
let running = true;
let scoreEl = document.getElementById('score');
let thumb = document.getElementById('thumb');

// Audio context
let audioCtx = null;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  // engine loop as buffered audio
  fetch('assets/engine_loop.wav').then(r=>r.arrayBuffer()).then(b=>audioCtx.decodeAudioData(b)).then(buf=>{
    const src = audioCtx.createBufferSource(); src.buffer = buf; src.loop = true;
    const gain = audioCtx.createGain(); gain.gain.value = 0.6;
    src.connect(gain); gain.connect(audioCtx.destination);
    src.start(0); window.engineSource = src; window.engineGain = gain;
  }).catch(()=>{});
}

function reset(){
  obstacles = []; spawnTimer=0; score=0; speed=7; player.lane=1; player.targetLane=1; player.lerpX=0;
  scoreEl.textContent=score;
}

function worldToScreen(lane, depth){ // depth 0..1 (0 far, 1 near)
  const roadW = W * 0.6;
  const left = (W - roadW)/2;
  // lane offset in road local coords
  const laneX = (lane + 0.5 - lanes/2) * (roadW/lanes) * (0.85);
  // perspective scaling: nearer -> larger offset
  const perspective = 0.2 + 0.8 * depth; // 0.2..1
  const screenX = W/2 + laneX * perspective;
  const screenY = H * (0.48 + 0.52 * depth); // map depth to vertical position
  return {x: screenX, y: screenY, scale: 0.4 + 0.9*depth};
}

function spawnObstacle(){
  const type = Math.random() < 0.6 ? 'car':'truck';
  const lane = Math.floor(Math.random()*lanes);
  obstacles.push({type:type, lane:lane, depth:0.0, speed: 0.002 + Math.random()*0.002, img: assets[type]});
}

function update(dt){
  if(!running) return;
  if(spawnTimer<=0){ spawnTimer = 500 + Math.random()*700; spawnObstacle(); }
  spawnTimer -= dt;
  // increase depth (towards player)
  for(let i=obstacles.length-1;i>=0;i--){
    obstacles[i].depth += (speed*0.0006) + obstacles[i].speed*dt*0.001;
    if(obstacles[i].depth >= 1.05){ // passed player
      obstacles.splice(i,1);
      score += 20;
      continue;
    }
  }
  // player lane interpolation (smooth)
  // compute target screen x slowly interpolate for smoothness
  const tDepth = 0.95; // player's depth near bottom
  const target = worldToScreen(player.targetLane, tDepth);
  player.lerpX += (target.x - player.lerpX) * Math.min(0.18, dt/16*0.18); // smoothing factor
  // collision: check any obstacle close to depth ~0.95 and overlapping x ranges
  for(let o of obstacles){
    if(Math.abs(o.depth - tDepth) < 0.06){
      const oScreen = worldToScreen(o.lane, o.depth);
      const px = player.lerpX; const py = H * 0.92;
      const ow = o.img.width * (0.35 * oScreen.scale); const oh = o.img.height * (0.35 * oScreen.scale);
      if(px + player.width*0.28 > oScreen.x - ow/2 && px + player.width*0.72 < oScreen.x + ow/2){
        // collision
        running = false;
        document.getElementById('instructions').textContent = 'GAME OVER - Tap to Restart';
        // play impact sound if available
        try{ fetch('assets/impact.wav').then(r=>r.arrayBuffer()).then(b=>audioCtx.decodeAudioData(b)).then(buf=>{const s=audioCtx.createBufferSource();s.buffer=buf; s.connect(audioCtx.destination); s.start();}); }catch(e){}
      }
    }
  }
  score += Math.floor(dt/16);
  scoreEl.textContent = score;
  speed += 0.00012 * dt;
}

function drawRoad(){
  // draw sky background strip
  if(assets.bg) ctx.drawImage(assets.bg, 0, 0, W, H*0.5);
  // perspective road as trapezoid
  const roadW = W*0.6;
  const left = (W-roadW)/2;
  const topW = W*0.06;
  // polygon points for road trapezoid
  ctx.fillStyle = '#555';
  ctx.beginPath();
  ctx.moveTo(W/2 - topW/2, H*0.08);
  ctx.lineTo(W/2 + topW/2, H*0.08);
  ctx.lineTo(left+roadW+40, H);
  ctx.lineTo(left-40, H);
  ctx.closePath();
  ctx.fill();
  // center dashed lines using perspective spacing
  ctx.strokeStyle = '#f7e22b'; ctx.lineWidth = 8; ctx.lineCap = 'round';
  // draw several dashes with varying depth
  for(let dpos=0; dpos<1.2; dpos+=0.06){
    const p1 = worldToScreen(lanes/2 - 0.5, dpos);
    const p2 = worldToScreen(lanes/2 - 0.5, Math.min(1.0, dpos+0.02));
    ctx.beginPath(); ctx.moveTo(p1.x-10, p1.y); ctx.lineTo(p2.x-10, p2.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p1.x+10, p1.y); ctx.lineTo(p2.x+10, p2.y); ctx.stroke();
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);
  drawRoad();
  // draw palms on sides (far -> near)
  if(assets.palm){
    for(let i=0;i<6;i++){
      const sx = 60 + i*260;
      ctx.drawImage(assets.palm, sx - assets.palm.width*0.08, H*0.55 - assets.palm.height*0.08, assets.palm.width*0.16, assets.palm.height*0.16);
      ctx.drawImage(assets.palm, W- sx - assets.palm.width*0.08, H*0.55 - assets.palm.height*0.08, assets.palm.width*0.16, assets.palm.height*0.16);
    }
  }
  // draw obstacles with perspective scaling (far small, near big)
  for(let o of obstacles){
    const s = worldToScreen(o.lane, o.depth);
    const scale = s.scale * 0.35;
    const w = o.img.width * scale; const h = o.img.height * scale;
    ctx.drawImage(o.img, s.x - w/2, s.y - h/2, w, h);
  }
  // draw player scooter at near depth
  const playerScreen = worldToScreen(player.lane, 0.95);
  const pw = player.width; const ph = player.height;
  // use lerpX for smooth horizontal pos
  ctx.drawImage(assets.scooter, player.lerpX - pw/2, H*0.82 - ph/2, pw, ph);
}

let last = performance.now();
function loop(now){
  const dt = now - last; last = now;
  update(dt); draw(); requestAnimationFrame(loop);
}

loadAssets(()=>{ reset(); // initialize player.lerpX to current lane pos
  const p = worldToScreen(player.lane, 0.95); player.lerpX = p.x;
  requestAnimationFrame(loop);
});

// Controls: smoother swipe handling with threshold + velocity + easing
const touchbar = document.getElementById('touchbar');
let dragging = false; let touchStartX = 0; let touchStartTime = 0;
touchbar.addEventListener('touchstart', (e)=>{ e.preventDefault(); initAudio(); dragging=true; touchStartX = e.touches[0].clientX; touchStartTime = performance.now(); });
touchbar.addEventListener('touchmove', (e)=>{ e.preventDefault(); if(!dragging) return; const x = e.touches[0].clientX; handleTouchMove(x); });
touchbar.addEventListener('touchend', (e)=>{ e.preventDefault(); dragging=false; const dt = performance.now()-touchStartTime; const dx = (lastTouchX || touchStartX) - touchStartX; processSwipeEnd(dx, dt); });
let lastTouchX = null;
touchbar.addEventListener('mousedown', (e)=>{ initAudio(); dragging=true; touchStartX = e.clientX; touchStartTime = performance.now(); });
window.addEventListener('mousemove', (e)=>{ if(dragging){ handleTouchMove(e.clientX); } });
window.addEventListener('mouseup', (e)=>{ if(dragging){ dragging=false; const dt = performance.now()-touchStartTime; const dx = (lastTouchX || touchStartX) - touchStartX; processSwipeEnd(dx, dt); } });

function handleTouchMove(clientX){
  lastTouchX = clientX;
  const rect = touchbar.getBoundingClientRect();
  const rel = Math.min(rect.width, Math.max(0, clientX - rect.left));
  const percent = rel / rect.width;
  // map continuous to target lane with smoothing
  const targetLane = Math.floor(percent * lanes);
  player.targetLane = Math.max(0, Math.min(lanes-1, targetLane));
  moveThumbToLane();
}

function processSwipeEnd(dx, dt){
  // quick flick to move extra lane(s) based on velocity
  const vx = dx / Math.max(1, dt);
  if(Math.abs(vx) > 0.5){
    if(vx > 0) player.targetLane = Math.min(lanes-1, player.targetLane + 1);
    else player.targetLane = Math.max(0, player.targetLane - 1);
  }
  moveThumbToLane();
}

function moveThumbToLane(){
  const rect = touchbar.getBoundingClientRect();
  const percent = (player.targetLane + 0.5)/lanes;
  const pos = Math.max(6, percent * rect.width - 18);
  thumb.style.left = pos + 'px';
}

// keyboard controls for convenience
window.addEventListener('keydown', (e)=>{
  if(e.key==='ArrowLeft'){ player.targetLane = Math.max(0, player.targetLane-1); moveThumbToLane(); }
  if(e.key==='ArrowRight'){ player.targetLane = Math.min(lanes-1, player.targetLane+1); moveThumbToLane(); }
  if(!running && (e.key===' '||e.key==='Enter')){ running=true; reset(); document.getElementById('instructions').textContent='HOLD AND SWIPE TO MOVE'; }
});

canvas.addEventListener('click', ()=>{ if(!running){ running=true; reset(); document.getElementById('instructions').textContent='HOLD AND SWIPE TO MOVE'; } else { initAudio(); } });

// init thumb position
setTimeout(moveThumbToLane, 200);
</script></body></html>