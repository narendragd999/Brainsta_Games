<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Klondike Solitaire - PixiJS</title>
<style>
  /* Root & body with gradient bg and full viewport */
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: linear-gradient(to bottom, #e5c1d1, #d3e6f5);
    display: flex; flex-direction: column; align-items: center;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    overflow: hidden;
  }
  #container {
    flex: 1 1 auto;
    display: flex; flex-direction: column; align-items: center;
    width: 100vw; max-width: 700px;
    max-height: 100vh;
    padding: 10px;
    box-sizing: border-box;
  }

  #gameCanvas {
    background: transparent;
    box-shadow: 0 0 40px rgba(150,80,190,0.2);
    border-radius: 15px;
    touch-action: none;
    align-self: center;
  }
  #statusBar {
    margin-top: 12px;
    width: 100%;
    max-width: 600px;
    display: grid;
    grid-template-columns: repeat(6, auto);
    justify-content: space-around;
    gap: 8px;
    color: #4a3f61;
    font-weight: 700;
    font-size: 1rem;
  }
  button {
    cursor: pointer;
    border: none;
    border-radius: 8px;
    background: #e5c1d1;
    color: #4a3f61;
    font-weight: 700;
    padding: 8px 12px;
    box-shadow: 0 3px 6px rgba(160,80,210,0.25);
    user-select: none;
    transition: background-color 0.3s ease;
  }
  button:hover {
    background-color: #d9b8c9;
  }
  button:active {
    background-color: #c899b6;
  }
  #helpModal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #f6f5f8;
    border-radius: 18px;
    box-shadow: 0 0 48px rgba(90,170,200,0.35);
    max-width: 400px;
    width: 90vw;
    padding: 24px 24px 12px 24px;
    z-index: 999;
    display: none;
  }
  #helpModal h2 {
    margin-top: 0;
    color: #9f749e;
    text-align: center;
    font-weight: 900;
  }
  #helpModal p {
    color: #55506d;
    font-size: 1rem;
    line-height: 1.4;
  }
  #helpClose {
    position: absolute;
    top: 10px; right: 12px;
    background: none;
    border: none;
    font-size: 1.8rem;
    color: #b38eb2;
    cursor: pointer;
    font-weight: 800;
    user-select: none;
  }
  #notification {
    position: fixed;
    top: 10px; right: 50%;
    transform: translateX(50%);
    background: #c7b0cddd;
    padding: 10px 26px;
    border-radius: 12px;
    box-shadow: 0 0 12px rgba(140, 50, 200, 0.3);
    color: #532d52;
    font-weight: 700;
    font-size: 1rem;
    user-select: none;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 1000;
  }
</style>
</head>
<body>
<div id="container">
  <canvas id="gameCanvas" width="700" height="900"></canvas>
  <div id="statusBar">
    <button id="newGameBtn" title="Start New Game">New Game</button>
    <button id="undoBtn" title="Undo Last Move">Undo</button>
    <button id="toggleDrawBtn" title="Toggle Draw 1 or Draw 3">Draw 1</button>
    <button id="toggleScoreBtn" title="Toggle Standard/Vegas Scoring">Standard</button>
    <button id="muteBtn" title="Mute/Unmute Sounds">Mute</button>
    <button id="helpBtn" title="Show Instructions">❔</button>
  </div>
</div>
<div id="helpModal" role="dialog" aria-modal="true">
  <button id="helpClose" aria-label="Close Help">&times;</button>
  <h2>How to Play Klondike Solitaire</h2>
  <p>
    - Build tableau stacks descending alternating colors.<br />
    - Move all cards to foundations by suit (Ace to King).<br />
    - Click/tap stock pile to draw cards.<br />
    - Double tap cards to auto-move to foundations if possible.<br />
    - Vegas scoring: Earn points for cards moved, with betting.<br />
    - Use Undo to backtrack moves.<br />
    - Win when all cards are in foundations.
  </p>
</div>
<div id="notification"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-/BkC55xAlVNFn9IL+qzxG/t6OsT2kflnzA06q66CxkOJq6BXCx5f+9b2OsaG+0OjZ0Z6DfN6I3T+MHaJtraMtg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
(() => {
  // Aliases
  const {Application, Container, Graphics, Text, TextStyle, Rectangle, Sprite, Texture, Ticker} = PIXI;

  // Constants
  const CARD_WIDTH = 82;
  const CARD_HEIGHT = 118;
  const CARD_CORNER_RADIUS = 14;
  const CARD_SPACING_Y = 28; // vertical offset per card in tableau
  const DECK_OFFSET_X = 16;
  const DECK_OFFSET_Y = 16;

  const COLORS = {
    red: 0xe57490,
    black: 0x4a518c,
    backgroundGradientTop: 0xe5c1d1,
    backgroundGradientBottom: 0xd3e6f5,
    highlight: 0xaa90ac,
    foundationPlaceholder: 0xbcb7de,
  };

  // Utils
  function shuffle(array) {
    for (let i=array.length-1; i>0; i--) {
      const j = Math.floor(Math.random() * (i+1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // Card class with programmatic SVG-like drawing
  class CardSprite extends Container {
    constructor(card) {
      super();
      this.card = card;
      this.faceUp = false;
      this.draw();
      this.interactive = true;
      this.buttonMode = true;
      this.anchor = {x: 0, y: 0};
      // To track dragging
      this.dragData = null;
      this.dragging = false;
      
      // Hit area
      this.hitArea = new Rectangle(0, 0, CARD_WIDTH, CARD_HEIGHT);

      this.on('pointerdown', this.onDragStart)
          .on('pointerup', this.onDragEnd)
          .on('pointerupoutside', this.onDragEnd)
          .on('pointermove', this.onDragMove)
          .on('pointertap', this.onTap.bind(this));

      // Double tap tracking
      this.lastTap = 0;
    }

    draw() {
      this.removeChildren();
      // Card base rectangle with shadow
      const g = new Graphics();
      g.lineStyle(2, 0x4a518c, 1);
      g.beginFill(0xffffff);
      g.drawRoundedRect(0, 0, CARD_WIDTH, CARD_HEIGHT, CARD_CORNER_RADIUS);
      g.endFill();
      this.addChild(g);

      if (!this.faceUp) {
        // Card back pattern (diagonal stripes)
        const back = new Graphics();
        back.beginFill(0xd3e6f5);
        back.drawRoundedRect(0, 0, CARD_WIDTH, CARD_HEIGHT, CARD_CORNER_RADIUS);
        back.endFill();
        this.addChild(back);

        const stripes = new Graphics();
        stripes.lineStyle(3, 0xe5c1d1, 0.6);
        for(let i=-CARD_HEIGHT; i<CARD_WIDTH; i+=14) {
          stripes.moveTo(i,0);
          stripes.lineTo(i+CARD_HEIGHT,CARD_HEIGHT);
        }
        this.addChild(stripes);
        return;
      }

      // Face up cards -- suit and rank drawn with vector graphics/text

      // Rank text top-left and bottom-right (rotated)
      const style = new TextStyle({
        fontFamily:'Arial',
        fontSize:20,
        fill: this.card.color === 'red' ? COLORS.red : COLORS.black,
        fontWeight: 'bold',
      });
      const rankTextTop = new Text(this.card.rankAbbr, style);
      rankTextTop.x = 8;
      rankTextTop.y = 8;
      this.addChild(rankTextTop);

      const suitTextTop = new Text(this.card.suitSymbol, style);
      suitTextTop.x = 8;
      suitTextTop.y = 32;
      this.addChild(suitTextTop);

      const rankTextBottom = new Text(this.card.rankAbbr, style);
      rankTextBottom.x = CARD_WIDTH - 12;
      rankTextBottom.y = CARD_HEIGHT - 12;
      rankTextBottom.rotation = Math.PI;
      rankTextBottom.anchor.set(0.5);
      this.addChild(rankTextBottom);

      const suitTextBottom = new Text(this.card.suitSymbol, style);
      suitTextBottom.x = CARD_WIDTH - 12;
      suitTextBottom.y = CARD_HEIGHT - 36;
      suitTextBottom.rotation = Math.PI;
      suitTextBottom.anchor.set(0.5);
      this.addChild(suitTextBottom);

      // Big center suit symbol
      const bigSuitStyle = new TextStyle({
        fontFamily:'Arial',
        fontSize: 40,
        fill: this.card.color === 'red' ? COLORS.red : COLORS.black,
      });
      const centerSuit = new Text(this.card.suitSymbol, bigSuitStyle);
      centerSuit.x = (CARD_WIDTH / 2);
      centerSuit.y = (CARD_HEIGHT / 2);
      centerSuit.anchor.set(0.5);
      this.addChild(centerSuit);
    }

    setFaceUp(faceUp) {
      this.faceUp = faceUp;
      this.draw();
    }

    onDragStart(event) {
      if (!this.faceUp) return; // Only draggable face up cards
      this.dragData = event.data;
      this.dragging = true;
      this.alpha = 0.8;
      this.zIndex = 1000;
      this.dragStartGlobal = this.dragData.getLocalPosition(this.parent);
      this.dragStartLocal = {x: this.x, y: this.y};
      this.parent.addChild(this); // Bring to front
    }

    onDragEnd() {
      if (!this.dragging) return;
      this.dragging = false;
      this.alpha = 1;
      // Emitting custom event for game logic handling
      this.emit('carddragend', this);
      this.dragData = null;
    }

    onDragMove() {
      if (this.dragging && this.dragData) {
        const newPosition = this.dragData.getLocalPosition(this.parent);
        this.x = this.dragStartLocal.x + (newPosition.x - this.dragStartGlobal.x);
        this.y = this.dragStartLocal.y + (newPosition.y - this.dragStartGlobal.y);
      }
    }

    onTap() {
      const now = performance.now();
      if (now - this.lastTap < 350) {
        // double tap detected
        this.emit('carddoubletap', this);
      }
      this.lastTap = now;
    }
  }

  // Card data class
  class Card {
    constructor(suit, rank) {
      this.suit = suit; // '♠ ♥ ♦ ♣'
      this.rank = rank; // 1 to 13
      this.faceUp = false;
      this.color = (suit === '♥' || suit === '♦') ? 'red' : 'black';
      this.rankAbbr = rank === 1 ? 'A' : rank === 11 ? 'J' : rank ===12 ? 'Q' : rank === 13 ? 'K' : rank.toString();
      this.suitSymbol = suit;
    }
  }

  // Game class core logic and renderer
  class KlondikeSolitaire {
    constructor(canvas) {
      this.app = new Application({
        view: canvas,
        backgroundAlpha: 0,
        resolution: window.devicePixelRatio || 1,
        autoDensity: true,
        antialias: true,
        resizeTo: window,
      });
      this.stage = this.app.stage;
      this.stage.sortableChildren = true;

      this.width = canvas.width;
      this.height = canvas.height;

      // Positions for areas
      this.margin = 20;
      this.foundationY = 25;
      this.stockY = 25;

      this.foundationXStart = 340; // foundation piles x start
      this.stockX = 20;
      this.wasteX = 120;

      this.tableauY = 170;
      this.tableauXStart = 20;
      this.cardSpacingX = CARD_WIDTH + 12;
      this.cardSpacingY = CARD_SPACING_Y;

      // State
      this.pack = [];
      this.stock = [];
      this.waste = [];
      this.foundations = [[], [], [], []];
      this.tableau = [[], [], [], [], [], [], []];
      this.selectedCards = null;
      this.dragging = false;
      this.drawCount = 1; // Draw 1 or 3
      this.vegasMode = false;
      // Scoring system
      this.score = 0;
      this.moves = 0;
      this.secondsElapsed = 0;
      this.timerId = null;

      // Undo Stack
      this.undoStack = [];

      // Sound enabled
      this.soundEnabled = true;

      // Create containers
      this.containers = {};
      this.createContainers();

      // Create UI buttons and status binding
      this.createUI();

      this.buildDeck();
      this.dealCards();

      this.setupTicker();
      this.setupInteraction();

      this.createAPI();

      this.showNotification("Welcome to Klondike Solitaire!");
      this.startTimer();
    }

    createContainers() {
      this.containers.tableau = new Container();
      this.containers.foundations = new Container();
      this.containers.stockWaste = new Container();

      this.stage.addChild(this.containers.stockWaste);
      this.stage.addChild(this.containers.foundations);
      this.stage.addChild(this.containers.tableau);
    }

    // Create DOM UI bindings
    createUI() {
      this.domNewGame = document.getElementById('newGameBtn');
      this.domUndo = document.getElementById('undoBtn');
      this.domToggleDraw = document.getElementById('toggleDrawBtn');
      this.domToggleScore = document.getElementById('toggleScoreBtn');
      this.domMute = document.getElementById('muteBtn');
      this.domHelp = document.getElementById('helpBtn');
      this.domStatusBar = document.getElementById('statusBar');
      this.helpModal = document.getElementById('helpModal');
      this.helpClose = document.getElementById('helpClose');
      this.notification = document.getElementById('notification');

      this.domNewGame.onclick = () => { this.resetGame(); };
      this.domUndo.onclick = () => { this.undoMove(); };
      this.domToggleDraw.onclick = () => { this.toggleDrawCount(); };
      this.domToggleScore.onclick = () => { this.toggleScoringMode(); };
      this.domMute.onclick = () => { this.toggleSound(); };
      this.domHelp.onclick = () => { this.toggleHelp(true); };
      this.helpClose.onclick = () => { this.toggleHelp(false); };
    }

    createAPI() {
      window.klondike = {
        reset: () => this.resetGame(),
        toggleVegas: () => this.toggleScoringMode(),
        getStats: () => ({
          moves: this.moves,
          time: this.secondsElapsed,
          score: this.score,
          vegas: this.vegasMode,
        }),
      };
    }

    buildDeck() {
      this.pack = [];
      const suits = ['♠','♥','♦','♣'];
      for(let suit of suits) {
        for(let r=1; r<=13; r++) {
          this.pack.push(new Card(suit, r));
        }
      }
      shuffle(this.pack);
    }

    dealCards() {
      // Reset all
      this.stock = [];
      this.waste = [];
      this.foundations = [[],[],[],[]];
      this.tableau = [[],[],[],[],[],[],[]];
      this.clearAllContainers();
      this.selectedCards = null;
      this.score = 0;
      this.moves = 0;
      this.secondsElapsed = 0;
      this.undoStack = [];
      this.updateUI();
      this.drawCount = 1;

      // Deal tableau: pile 0 gets 1 card face up on top, pile 1 gets 2 cards with last one face up, etc.
      let deckIndex = 0;
      for (let i=0; i<7; i++) {
        for (let j=0; j<=i; j++) {
          let card = this.pack[deckIndex++];
          card.faceUp = (j === i);
          this.tableau[i].push(card);
        }
      }
      // Rest goes into stock face down
      for (; deckIndex < this.pack.length; deckIndex++) {
        this.stock.push(this.pack[deckIndex]);
        this.stock[this.stock.length-1].faceUp = false;
      }
      this.renderAll();
      this.saveUndo();
    }

    clearAllContainers() {
      this.containers.tableau.removeChildren();
      this.containers.foundations.removeChildren();
      this.containers.stockWaste.removeChildren();
    }

    renderAll() {
      this.renderDeck();
      this.renderFoundations();
      this.renderTableau();
      this.updateUI();
    }
    // Render Deck (Stock and Waste)
    renderDeck() {
      this.containers.stockWaste.removeChildren();

      // Stock
      if (this.stock.length > 0) {
        const topCard = this.stock[this.stock.length - 1];
        let cardSpr = new CardSprite(topCard);
        cardSpr.position.set(this.stockX, this.stockY);
        cardSpr.setFaceUp(false);
        cardSpr.on('pointerdown', () => this.onStockClick());
        this.containers.stockWaste.addChild(cardSpr);
      } else {
        // Empty Stock placeholder rectangle
        const emptyStock = new Graphics();
        emptyStock.lineStyle(3, COLORS.foundationPlaceholder, 0.75);
        emptyStock.drawRoundedRect(this.stockX, this.stockY, CARD_WIDTH, CARD_HEIGHT, CARD_CORNER_RADIUS);
        this.containers.stockWaste.addChild(emptyStock);
      }

      // Waste pile top card
      if (this.waste.length > 0) {
        const wasteCard = this.waste[this.waste.length - 1];
        let cardSpr = new CardSprite(wasteCard);
        cardSpr.position.set(this.wasteX, this.stockY);
        cardSpr.setFaceUp(true);
        cardSpr.on('pointerdown', (e) => {
          e.stopPropagation();
          this.onWasteCardClick(wasteCard);
        });
        cardSpr.on('carddoubletap', () => this.tryMoveCardToFoundation(wasteCard));
        this.containers.stockWaste.addChild(cardSpr);
      }
    }
    // Render Foundations
    renderFoundations() {
      this.containers.foundations.removeChildren();
      for(let i=0; i<4; i++) {
        const foundation = this.foundations[i];
        const placeX = this.foundationXStart + i * this.cardSpacingX;
        const placeY = this.foundationY;
        if (foundation.length === 0) {
          // Placeholder rectangle with 'A'
          const base = new Graphics();
          base.lineStyle(2.5, COLORS.foundationPlaceholder, 0.7);
          base.drawRoundedRect(0, 0, CARD_WIDTH, CARD_HEIGHT, CARD_CORNER_RADIUS);
          base.position.set(placeX, placeY);
          this.containers.foundations.addChild(base);

          const text = new Text('A', new TextStyle({fontSize: 48, fill: COLORS.foundationPlaceholder}));
          text.position.set(placeX + CARD_WIDTH/2, placeY + CARD_HEIGHT/2);
          text.anchor.set(0.5);
          this.containers.foundations.addChild(text);
        } else {
          const topCard = foundation[foundation.length - 1];
          const cardSpr = new CardSprite(topCard);
          cardSpr.setFaceUp(true);
          cardSpr.position.set(placeX, placeY);
          cardSpr.interactive = true;
          cardSpr.buttonMode = true;
          cardSpr.on('pointerdown', () => this.onFoundationClick(i));
          this.containers.foundations.addChild(cardSpr);
        }
      }
    }

    renderTableau() {
      this.containers.tableau.removeChildren();
      for(let i=0; i<7; i++) {
        const pile = this.tableau[i];
        const baseX = this.tableauXStart + i * this.cardSpacingX;
        for(let j=0; j<pile.length; j++) {
          const card = pile[j];
          const cardSprite = new CardSprite(card);
          cardSprite.setFaceUp(card.faceUp);
          cardSprite.position.set(baseX, this.tableauY + j * this.cardSpacingY);
          cardSprite.interactive = card.faceUp;
          cardSprite.buttonMode = card.faceUp;
          cardSprite.on('pointerdown', (e) => this.onTableauCardDown(i, j, cardSprite, e));
          cardSprite.on('carddoubletap', () => this.autoMoveCard(card, i, j));
          cardSprite.on('carddragend', (sprite) => this.onCardDragEnd(sprite, i, j));
          this.containers.tableau.addChild(cardSprite);
        }
      }
    }

    updateUI() {
      const scoreStr = this.vegasMode ? `Vegas Score: ${this.score}` : `Score: ${this.score}`;
      const timeStr = `Time: ${this.formatTime(this.secondsElapsed)}`;
      const movesStr = `Moves: ${this.moves}`;

      this.domToggleDraw.textContent = `Draw ${this.drawCount}`;
      this.domToggleScore.textContent = this.vegasMode ? 'Vegas' : 'Standard';
      this.domMute.textContent = this.soundEnabled ? 'Mute' : 'Unmute';

      const statusParts = [timeStr, movesStr, scoreStr];
      // Update status bar other parts accordingly
    }

    formatTime(sec) {
      const m = Math.floor(sec/60);
      const s = sec % 60;
      return m.toString().padStart(2,'0') + ':' + s.toString().padStart(2,'0');
    }

    startTimer() {
      if(this.timerId) clearInterval(this.timerId);
      this.timerId = setInterval(() => {
        this.secondsElapsed++;
        this.updateUI();
      }, 1000);
    }

    stopTimer() {
      if(this.timerId) clearInterval(this.timerId);
    }

    // Event handlers below - minimal for brevity; expand to full implementation in real build

    onStockClick() {
      if(this.stock.length === 0) {
        // Reset stock from waste
        this.stock = this.waste.reverse().map(c => {c.faceUp = false; return c;});
        this.waste = [];
        this.moves++;
        this.updateUI();
        this.renderDeck();
        this.playSound('slide');
        this.saveUndo();
        return;
      }
      // Draw count cards from stock to waste
      for (let i=0; i<this.drawCount; i++){
        if(this.stock.length === 0) break;
        const card = this.stock.pop();
        card.faceUp = true;
        this.waste.push(card);
      }
      this.moves++;
      this.updateUI();
      this.renderDeck();
      this.playSound('flip');
      this.saveUndo();
    }

    onWasteCardClick(card) {
      // Try move waste card to tableau or foundation as per rules; placeholder triggers auto move
      this.tryMoveCardToFoundation(card) || this.playSound('slide');
    }

    onFoundationClick(index) {
      // Implement moving cards from tableau or waste to foundation via click; Placeholder no-op
    }

    // Selected card movement variables
    onTableauCardDown(pileIndex, cardIndex, cardSprite, event) {
      if (!cardSprite.faceUp) return;
      // Save drag start state for possible move or cancel
      this.selectedCards = {
        pileIndex,
        cardIndex,
        cards: this.tableau[pileIndex].slice(cardIndex),
        sprite: cardSprite,
        dragStartPos: {x: cardSprite.x, y: cardSprite.y},
        dragging: false,
      };
      cardSprite.on('pointermove', this.onDragMove.bind(this));
      cardSprite.on('pointerup', this.onDragEnd.bind(this));
      cardSprite.on('pointerupoutside', this.onDragEnd.bind(this));
      this.selectedCards.dragging = true;
      cardSprite.alpha = 0.7;
      this.stage.addChild(cardSprite);
      this.playSound('slide');
    }

    onDragMove(event) {
      if (!this.selectedCards) return;
      const pos = event.data.getLocalPosition(this.stage);
      this.selectedCards.sprite.x = pos.x - CARD_WIDTH / 2;
      this.selectedCards.sprite.y = pos.y - CARD_HEIGHT / 2;
    }

    onDragEnd(event) {
      if (!this.selectedCards) return;

      // Determine if valid move to tableau pile, foundation, or revert
      // For brevity: revert to original pos
      this.selectedCards.sprite.position.set(this.selectedCards.dragStartPos.x, this.selectedCards.dragStartPos.y);
      this.selectedCards.sprite.alpha = 1;
      this.selectedCards = null;
      this.renderAll();
      this.updateUI();
      this.saveUndo();
    }

    onCardDragEnd(sprite, pileIndex, cardIndex) {
      // Placeholder to handle drop after drag
      this.onDragEnd();
    }

    tryMoveCardToFoundation(card) {
      // Attempt to move a card to foundation piles if legal
      for(let i=0; i<4; i++) {
        const foundation = this.foundations[i];
        if(this.canPlaceOnFoundation(card, foundation)) {
          // Remove from waste or tableau and add to foundation
          this.removeCardFromCurrentPlace(card);
          foundation.push(card);
          this.moves++;
          this.updateScoreOnFoundation(card);
          this.renderAll();
          this.playSound('slide');
          this.saveUndo();
          this.checkWin();
          return true;
        }
      }
      return false;
    }

    canPlaceOnFoundation(card, foundation) {
      if (foundation.length === 0) {
        return card.rank === 1; // Ace
      }
      const topCard = foundation[foundation.length - 1];
      return card.suit === topCard.suit && card.rank === topCard.rank + 1;
    }

    removeCardFromCurrentPlace(card) {
      const fromArrs = [this.waste, ...this.tableau, ...this.foundations];
      for(const arr of fromArrs) {
        const index = arr.indexOf(card);
        if(index >= 0) {
          arr.splice(index, 1);
          break;
        }
      }
    }

    updateScoreOnFoundation(card) {
      if (this.vegasMode) this.score += 5;
      else this.score += 10; // simple example scoring
    }

    toggleDrawCount() {
      this.drawCount = (this.drawCount === 1) ? 3 : 1;
      this.domToggleDraw.textContent = `Draw ${this.drawCount}`;
      this.showNotification(`Draw mode: ${this.drawCount}`);
      this.renderDeck();
    }

    toggleScoringMode() {
      this.vegasMode = !this.vegasMode;
      this.score = 0; // reset score for simplicity
      this.domToggleScore.textContent = this.vegasMode ? 'Vegas' : 'Standard';
      this.showNotification(this.vegasMode ? 'Vegas Scoring Enabled' : 'Standard Scoring Enabled');
      this.updateUI();
    }

    toggleSound() {
      this.soundEnabled = !this.soundEnabled;
      this.domMute.textContent = this.soundEnabled ? 'Mute' : 'Unmute';
      this.showNotification(this.soundEnabled ? 'Sound ON' : 'Sound OFF');
    }

    toggleHelp(show) {
      this.helpModal.style.display = show ? 'block' : 'none';
    }

    // Undo support with deep state snapshot (simplified)
    saveUndo() {
      if(this.undoStack.length > 50) this.undoStack.shift();
      // Deep clone minimal necessary state arrays
      const snapshot = {
        stock: [...this.stock],
        waste: [...this.waste],
        foundations: this.foundations.map(f => [...f]),
        tableau: this.tableau.map(t => [...t]),
        score: this.score,
        moves: this.moves,
        secondsElapsed: this.secondsElapsed,
        drawCount: this.drawCount,
        vegasMode: this.vegasMode,
      };
      this.undoStack.push(snapshot);
    }

    undoMove() {
      if (this.undoStack.length < 2) {
        this.showNotification("Nothing to undo");
        return;
      }
      // Drop current state
      this.undoStack.pop();
      const snapshot = this.undoStack[this.undoStack.length-1];
      this.stock = [...snapshot.stock];
      this.waste = [...snapshot.waste];
      this.foundations = snapshot.foundations.map(f => [...f]);
      this.tableau = snapshot.tableau.map(t => [...t]);
      this.score = snapshot.score;
      this.moves = snapshot.moves;
      this.secondsElapsed = snapshot.secondsElapsed;
      this.drawCount = snapshot.drawCount;
      this.vegasMode = snapshot.vegasMode;

      this.renderAll();
      this.updateUI();
      this.showNotification("Undo successful");
    }

    formatTime(s) {
      let minutes = Math.floor(s / 60);
      let seconds = s % 60;
      return `${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
    }

    showNotification(msg) {
      if(!this.notification) return;
      this.notification.textContent = msg;
      this.notification.style.opacity = '1';
      clearTimeout(this.notifTimeout);
      this.notifTimeout = setTimeout(() => {
        this.notification.style.opacity = '0';
      }, 1800);
    }

    playSound(type) {
      if(!this.soundEnabled) return;
      // Placeholder: implement audio using Audio or Web Audio API here
      // E.g. play flip, slide, win sounds
      // For demo, skipped actual sound implementation
    }

    autoMoveCard(card, pileIndex, cardIndex) {
      const moved = this.tryMoveCardToFoundation(card);
      if (!moved) this.showNotification("Can't auto move card");
    }

    checkWin() {
      if(this.foundations.every(f => f.length === 13)) {
        this.showNotification("You Won! 🎉");
        this.playSound('win');
        this.stopTimer();
        this.celebrate();
      }
    }

    celebrate() {
      // Basic confetti/star animation placeholder
      let count = 50;
      let container = new Container();
      this.stage.addChild(container);
      for(let i=0;i<count;i++) {
        let star = new Graphics();
        star.beginFill(0xe57490, 1);
        star.drawStar(0,0,5,5);
        star.endFill();
        star.x = Math.random()*this.width;
        star.y = -10;
        star.vy = 2+Math.random()*3;
        container.addChild(star);
      }
      const ticker = new Ticker();
      ticker.add(() => {
        container.children.forEach(star => {
          star.y += star.vy;
          star.rotation += 0.05;
          if (star.y > this.height + 10) star.y = -10;
        });
        ticker.update();
      });
      ticker.start();
      setTimeout(() => {
        ticker.stop();
        container.destroy({children:true});
      }, 5000);
    }

    resetGame() {
      this.stopTimer();
      this.buildDeck();
      this.dealCards();
      this.startTimer();
      this.showNotification('New game started');
    }

    setupTicker() {
      this.app.ticker.add(() => {
        // periodic updates if needed
      });
    }

    setupInteraction() {
      // Resize event for responsiveness
      window.addEventListener('resize', () => {
        // Adjust canvas scale and card positions for responsiveness if desired (auto scaled by PIXI here)
      });
    }
  }

  // Instantiate game
  const canvas = document.getElementById('gameCanvas');
  const game = new KlondikeSolitaire(canvas);
})();
</script>
</body>
</html>
