<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Klondike Solitaire ‚Äî PixiJS (Full)</title>
  <meta name="description" content="Responsive Klondike Solitaire using PixiJS and MIT card assets (hayeah). Mobile friendly, drag/touch, undo, vegas scoring." />
  <style>
    :root{ --bg-top:#e5c1d1; --bg-bottom:#d3e6f5; }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--bg-top),var(--bg-bottom));padding:12px}
    #ui{position:absolute;top:12px;left:50%;transform:translateX(-50%);display:flex;gap:8px;align-items:center;z-index:60}
    .btn{background:#fff;border:0;padding:8px 12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.12);cursor:pointer;font-weight:700}
    .pill{background:#fff;padding:8px 12px;border-radius:999px;box-shadow:0 8px 24px rgba(0,0,0,.08);font-weight:800}
    #canvasWrap{width:min(1200px,98vw);height:min(800px,92vh);border-radius:18px;overflow:hidden;box-shadow:0 26px 60px rgba(0,0,0,.16);background:linear-gradient(180deg,rgba(255,255,255,0.95),rgba(255,255,255,0.85));display:flex;align-items:center;justify-content:center}
    #credits{position:absolute;right:12px;bottom:10px;font-size:12px;color:#222;background:rgba(255,255,255,0.8);padding:6px 8px;border-radius:8px}
    #helpModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.36);z-index:100}
    .modalCard{background:#fff;padding:18px;border-radius:12px;max-width:520px}
    @media (max-width:720px){ #ui{flex-wrap:wrap;gap:6px} }
  </style>
</head>
<body>
  <div id="ui">
    <button id="newBtn" class="btn">New</button>
    <button id="undoBtn" class="btn">Undo</button>
    <button id="autoBtn" class="btn">Auto</button>
    <button id="drawToggle" class="btn">Draw: 1</button>
    <button id="vegasToggle" class="btn">Vegas: Off</button>
    <div class="pill" id="moves">Moves: 0</div>
    <div class="pill" id="timer">Time: 00:00</div>
    <button id="muteBtn" class="btn">üîä</button>
    <button id="helpBtn" class="btn">‚ùî</button>
  </div>

  <div id="canvasWrap"></div>

  <div id="helpModal"><div class="modalCard"><div style="display:flex;justify-content:space-between;align-items:center"><h3 style="margin:0">How to play</h3><button id="closeHelp" class="btn">Close</button></div>
    <p>Move all cards to the Foundations (A‚ÜíK) by suit. Build tableau piles down in alternating colors. Tap/click the Stock to draw. Drag cards to move stacks. Double-tap a top card to auto-move to Foundation when legal. Vegas scoring option available.</p>
  </div></div>

  <div id="credits">Cards: hayeah/playing-cards-assets (MIT)</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
<script>
// Full Klondike Solitaire using PixiJS + hayeah playing-cards-assets (MIT) from GitHub CDN
(() => {
  const base = 'https://raw.githubusercontent.com/hayeah/playing-cards-assets/master/png';
  const rankNames = ['ace','2','3','4','5','6','7','8','9','10','jack','queen','king'];
  const suits = ['clubs','diamonds','hearts','spades'];

  // PIXI init
  const canvasWrap = document.getElementById('canvasWrap');
  const app = new PIXI.Application({ backgroundAlpha: 0, resizeTo: canvasWrap, antialias:true });
  canvasWrap.appendChild(app.view);

  // UI elements
  const newBtn = document.getElementById('newBtn');
  const undoBtn = document.getElementById('undoBtn');
  const autoBtn = document.getElementById('autoBtn');
  const drawToggle = document.getElementById('drawToggle');
  const vegasToggle = document.getElementById('vegasToggle');
  const movesPill = document.getElementById('moves');
  const timerPill = document.getElementById('timer');
  const muteBtn = document.getElementById('muteBtn');
  const helpBtn = document.getElementById('helpBtn');
  const helpModal = document.getElementById('helpModal');
  const closeHelp = document.getElementById('closeHelp');

  // game state
  let draw3 = false; let vegas = false; let muted = false;
  let state = null; let undoStack = []; let startTs = Date.now(); let timerInt = null;
  let moves = 0; let vegasScore = 0;

  // resources
  const loader = new PIXI.AssetLoader(); // for types compatibility - we'll use PIXI.Loader
  const loaderPIXI = new PIXI.Loader();

  // register textures for each card
  for (const s of suits){
    for (const r of rankNames){
      const key = `${r}_of_${s}`;
      const url = `${base}/${r}_of_${s}.png`;
      loaderPIXI.add(key, url);
    }
  }
  loaderPIXI.add('back', base+'/back.png');

  loaderPIXI.load(setup);

  // helper maps
  const rankValue = (r)=>{ // 1..13
    if (r==='ace') return 1; if (r==='jack') return 11; if (r==='queen') return 12; if (r==='king') return 13; return parseInt(r,10);
  };

  function makeDeck(){
    const d = [];
    for (const s of suits){ for (const r of rankNames){ d.push({r, s, id: `${r}_of_${s}`, val: rankValue(r) }); } }
    return d;
  }

  function shuffle(array){ for(let i=array.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [array[i],array[j]]=[array[j],array[i]]; } }

  // display helpers: compute layout positions relative to canvas size
  function layout(){
    const w = app.renderer.width, h = app.renderer.height;
    const cardW = Math.min(96, Math.max(56, Math.floor(w * 0.08)));
    const cardH = Math.round(cardW * 1.4);
    const leftMargin = Math.round(w * 0.04);
    const gap = Math.round(cardW * 0.18);
    return {w,h,cardW,cardH,leftMargin,gap};
  }

  // central containers
  const pilesContainer = new PIXI.Container(); app.stage.addChild(pilesContainer);

  // hold references
  let stockS=[], wasteS=[], foundationS=[[],[],[],[]], tableauS=[[],[],[],[],[],[],[]];

  function setup(){
    // create green felt background
    const bg = new PIXI.Graphics(); bg.beginFill(0x0f7a53); bg.drawRoundedRect(0,0,app.renderer.width, app.renderer.height, 14); bg.endFill(); bg.alpha = 1; app.stage.addChildAt(bg, 0);
    // responsive: redraw bg on resize
    app.renderer.on('resize', ()=>{ bg.clear(); bg.beginFill(0x0f7a53); bg.drawRoundedRect(0,0,app.renderer.width, app.renderer.height, 14); bg.endFill(); layoutAndRender(); });

    // UI bindings
    newBtn.onclick = ()=>{ pushUndo(); startNewDeal(); };
    undoBtn.onclick = ()=>{ undo(); };
    autoBtn.onclick = ()=>{ autoMoveToFoundations(); };
    drawToggle.onclick = ()=>{ draw3 = !draw3; drawToggle.textContent = draw3? 'Draw: 3':'Draw: 1'; };
    vegasToggle.onclick = ()=>{ vegas = !vegas; vegasToggle.textContent = vegas? 'Vegas: On':'Vegas: Off'; resetVegas(); };
    muteBtn.onclick = ()=>{ muted = !muted; muteBtn.textContent = muted? 'üîá':'üîä'; };
    helpBtn.onclick = ()=>{ helpModal.style.display = 'flex'; };
    closeHelp.onclick = ()=>{ helpModal.style.display = 'none'; };

    // start
    startNewDeal();
    startTimer();
  }

  function startTimer(){ if(timerInt) clearInterval(timerInt); startTs = Date.now(); timerInt = setInterval(()=>{ const s = Math.floor((Date.now()-startTs)/1000); const mm = String(Math.floor(s/60)).padStart(2,'0'); const ss = String(s%60).padStart(2,'0'); timerPill.textContent = `Time: ${mm}:${ss}`; }, 1000); }

  function resetVegas(){ vegasScore = 0; updateMovesDisplay(); }

  function startNewDeal(){
    // clear stage
    pilesContainer.removeChildren(); stockS=[]; wasteS=[]; foundationS=[[],[],[],[]]; tableauS=[[],[],[],[],[],[],[]]; undoStack=[]; moves=0; updateMovesDisplay();

    // generate deck and shuffle
    const deck = makeDeck(); shuffle(deck);

    // deal tableau
    for (let col=0; col<7; col++){
      for (let i=0;i<=col;i++){
        const c = deck.pop(); const sprite = makeCardSprite(c); sprite.faceUp = (i===col); updateSprite(sprite);
        sprite.col = col; sprite.index = tableauS[col].length; tableauS[col].push(sprite); pilesContainer.addChild(sprite);
      }
    }
    // remaining deck -> stock
    while(deck.length){ const c = deck.pop(); const sprite = makeCardSprite(c); sprite.faceUp=false; updateSprite(sprite); stockS.push(sprite); pilesContainer.addChild(sprite); }

    layoutAndRender();
  }

  function makeCardSprite(cardData){ const tex = loaderPIXI.resources[cardData.id].texture; const sprite = new PIXI.Sprite(tex); sprite.anchor.set(0.5); sprite.width = layout().cardW; sprite.height = layout().cardH; sprite.data = cardData; sprite.interactive = true; sprite.on('pointerdown', onPointerDown); sprite.on('pointerup', onPointerUp); sprite.on('pointerupoutside', onPointerUpOutside); sprite.on('pointermove', onPointerMove); sprite.lastTap = 0; sprite.faceUp = !!cardData.faceUp; return sprite; }

  function updateSprite(sprite){ if(sprite.faceUp){ sprite.texture = loaderPIXI.resources[sprite.data.id].texture; } else sprite.texture = loaderPIXI.resources['back'].texture; }

  // layout and position sprites based on game arrays
  function layoutAndRender(){ const L = layout();
    // compute positions
    const topY = Math.round(L.h * 0.06) + L.cardH/2;
    const left = L.leftMargin + L.cardW/2;
    const colGap = L.cardW + L.gap;

    // foundations positions (right side)
    const foundationsXStart = L.w - L.leftMargin - (L.cardW/2) - 3*colGap;

    // stock & waste positions
    const stockX = left; const stockY = topY;
    const wasteX = left + colGap; const wasteY = topY;

    // position stock sprites stacked
    for (let i=0;i<stockS.length;i++){ const s = stockS[i]; s.width = L.cardW; s.height = L.cardH; s.x = stockX; s.y = stockY + Math.min(1, i*0.3); s.zIndex = 10 + i; s.alpha = 1; s.faceUp = false; updateSprite(s); }
    // waste (show top only)
    for (let i=0;i<wasteS.length;i++){ const s = wasteS[i]; s.width=L.cardW; s.height=L.cardH; s.x = wasteX + i*0.18*L.cardW; s.y = wasteY; s.zIndex = 50 + i; updateSprite(s); }

    // foundations positions (4 piles)
    for (let f=0;f<4;f++){ const fx = foundationsXStart + f*colGap; const fy = topY; const topCard = foundationS[f][foundationS[f].length-1]; if(topCard){ topCard.x = fx; topCard.y = fy; topCard.width=L.cardW; topCard.height=L.cardH; updateSprite(topCard); } }

    // tableau columns
    const tableauYStart = topY + L.cardH + Math.round(L.cardH*0.18);
    for (let c=0;c<7;c++){ const colX = left + c*colGap; const col = tableauS[c]; if(col.length===0){ /* placeholder drawing not necessary for Pixi */ } for (let i=0;i<col.length;i++){ const card = col[i]; card.width=L.cardW; card.height=L.cardH; card.x = colX; card.y = tableauYStart + i*(L.cardH*0.28); updateSprite(card); } }

    // sort children by zIndex
    pilesContainer.children.sort((a,b)=> (a.zIndex||0)-(b.zIndex||0));
  }

  // pointer/drag handling
  let dragging = null;
  function onPointerDown(e){
    const sprite = e.currentTarget; sprite.dragStart = { x:e.data.global.x, y:e.data.global.y }; sprite.dragTarget = { startX: sprite.x, startY: sprite.y };
    // detect double-tap
    const now = Date.now(); if(now - sprite.lastTap < 300){ // double tap
      sprite.lastTap = 0; if(handleAutoMoveAttempt(sprite)) return; }
    sprite.lastTap = now;
    // determine movable stack
    const loc = findSpriteLocation(sprite);
    if(!loc) return;
    if(loc.zone==='tableau'){ const col = tableauS[loc.col]; const index = loc.index; if(!col[index].faceUp) return; // cannot drag face-down
      const moving = col.slice(index);
      beginDrag(sprite, moving, loc);
    } else if(loc.zone==='waste'){ if(sprite !== wasteS[wasteS.length-1]) return; beginDrag(sprite, [sprite], loc); }
    else if(loc.zone==='foundation'){ /* foundations not draggable */ return; }
  }

  function beginDrag(sprite, moving, from){
    pushUndo();
    dragging = { moving, from, pointerId: null };
    // bring to top: set zIndex
    dragging.moving.forEach((s,idx)=>{ s.zIndex = 1000 + idx; app.stage.addChild(s); });
  }

  function onPointerMove(e){ if(!dragging) return; const p = e.data.global; const dx = p.x - (e.currentTarget.dragStart?.x || p.x); const dy = p.y - (e.currentTarget.dragStart?.y || p.y); // move stack
    const base = dragging.moving[0]; const ox = p.x; const oy = p.y; for(let i=0;i<dragging.moving.length;i++){ const c = dragging.moving[i]; c.x = ox; c.y = oy + i*(c.height*0.28); }
    highlightDropTargets(p.x,p.y);
  }

  function onPointerUp(e){ if(!dragging) return; const p = e.data.global; const target = findDropTarget(p.x,p.y); if(target){ // validate and commit
      if(target.type==='foundation'){
        // only single card allowed
        if(dragging.moving.length===1 && canMoveToFoundation(dragging.moving[0], target.index)){
          commitMoveToFoundation(dragging.from, target.index, dragging.moving[0]);
        } else rollbackDrag();
      } else if(target.type==='tableau'){
        const destCol = tableauS[target.index]; const lower = destCol[destCol.length-1] || null;
        if(canStackOnTableau(dragging.moving[0], lower)){
          commitMoveToTableau(dragging.from, target.index, dragging.moving);
        } else rollbackDrag();
      } else rollbackDrag();
    } else rollbackDrag();
    clearDropHighlights(); dragging = null; layoutAndRender();
  }
  function onPointerUpOutside(e){ onPointerUp(e); }

  function findSpriteLocation(sprite){ // search in tableau, waste, foundations
    for(let c=0;c<7;c++){ const col = tableauS[c]; for(let i=0;i<col.length;i++) if(col[i]===sprite) return {zone:'tableau', col:c, index:i}; }
    for(let i=0;i<wasteS.length;i++) if(wasteS[i]===sprite) return {zone:'waste', index:i};
    for(let f=0;f<4;f++){ const arr = foundationS[f]; if(arr.length && arr[arr.length-1]===sprite) return {zone:'foundation', index:f}; }
    for(let i=0;i<stockS.length;i++) if(stockS[i]===sprite) return {zone:'stock', index:i};
    return null;
  }

  function rollbackDrag(){ // return moving sprites to original source
    const from = dragging.from;
    if(from.zone==='tableau'){ const col = tableauS[from.col]; // remove any moved copies from stage then reassign original ordering
      layoutAndRender(); }
    else if(from.zone==='waste'){ layoutAndRender(); }
    else layoutAndRender();
  }

  function highlightDropTargets(x,y){ clearDropHighlights(); // foundations
    for(let i=0;i<4;i++){ const fx = foundationScreenPos(i); const r = {left:fx.x - L.cardW/2, right:fx.x + L.cardW/2, top:fx.y - L.cardH/2, bottom:fx.y + L.cardH/2}; if(x>=r.left && x<=r.right && y>=r.top && y<=r.bottom){ pilesContainer.children.forEach(ch=>{ /* no-op visual highlight implemented as outline on DOM not Pixi; skip */ }); } }
  }

  function clearDropHighlights(){ /* placeholder */ }

  function findDropTarget(x,y){ // return {type:'foundation'|'tableau', index}
    const L = layout(); const topY = Math.round(L.h * 0.06) + L.cardH/2; const left = L.leftMargin + L.cardW/2; const colGap = L.cardW + L.gap; const foundationsXStart = L.w - L.leftMargin - (L.cardW/2) - 3*colGap;
    // foundations
    for(let f=0;f<4;f++){ const fx = foundationsXStart + f*colGap; const fy = topY; const halfW = L.cardW/2; const halfH = L.cardH/2; if(x>=fx-halfW && x<=fx+halfW && y>=fy-halfH && y<=fy+halfH) return {type:'foundation', index:f}; }
    // tableau columns
    const tableauYStart = topY + L.cardH + Math.round(L.cardH*0.18);
    for(let c=0;c<7;c++){ const colX = left + c*colGap; const colTop = tableauYStart; const colBottom = app.renderer.height - 20; const halfW=L.cardW/2; if(x>=colX-halfW && x<=colX+halfW && y>=colTop-20 && y<=colBottom) return {type:'tableau', index:c}; }
    return null;
  }

  function foundationScreenPos(idx){ const L=layout(); const topY = Math.round(L.h * 0.06) + L.cardH/2; const left = L.leftMargin + L.cardW/2; const colGap = L.cardW + L.gap; const foundationsXStart = L.w - L.leftMargin - (L.cardW/2) - 3*colGap; return { x: foundationsXStart + idx*colGap, y: topY }; }

  function commitMoveToFoundation(from, fIdx, sprite){ // remove sprite from source and push to foundation
    removeSpriteFromSource(from, sprite); foundationS[fIdx].push(sprite); moves++; if(vegas) vegasScore += 5; playSound('move'); updateMovesDisplay(); flipIfNeeded(from); }
  function commitMoveToTableau(from, tIdx, moving){ removeSpriteFromSource(from, ...moving); tableauS[tIdx] = tableauS[tIdx].concat(moving); moves++; playSound('move'); updateMovesDisplay(); flipIfNeeded(from); }

  function removeSpriteFromSource(from, ...items){ if(from.zone==='tableau'){ const col = tableauS[from.col]; col.splice(from.index, items.length); } else if(from.zone==='waste'){ wasteS.pop(); } }

  function flipIfNeeded(from){ if(from.zone==='tableau'){ const col = tableauS[from.col]; if(col.length && !col[col.length-1].faceUp){ col[col.length-1].faceUp = true; updateSprite(col[col.length-1]); } } layoutAndRender(); checkWinAndCelebrate(); }

  function playSound(name){ if(muted) return; try{ // simple beep using WebAudio
      const ctx = new (window.AudioContext||window.webkitAudioContext)(); const o = ctx.createOscillator(); const g = ctx.createGain(); o.connect(g); g.connect(ctx.destination); if(name==='move'){ o.frequency.value = 600; g.gain.value = 0.02; } else if(name==='win'){ o.frequency.value = 880; g.gain.value = 0.03; } o.start(); setTimeout(()=>{ o.stop(); ctx.close(); }, 120); }catch(e){}
  }

  function flipStock(){ pushUndo(); if(stockS.length){ // draw
      const take = draw3?3:1; let drawn = []; for(let i=0;i<take && stockS.length;i++){ const c = stockS.pop(); c.faceUp = true; updateSprite(c); wasteS.push(c); drawn.push(c); }
      moves++; playSound('move'); updateMovesDisplay(); } else { // recycle waste to stock
      while(wasteS.length){ const c = wasteS.pop(); c.faceUp = false; updateSprite(c); stockS.push(c); } playSound('move'); }
    layoutAndRender(); }

  // attach click to stock area
  app.view.addEventListener('click', (e)=>{ // detect clicks near stock area
    const rect = app.view.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top; const L = layout(); const stockX = L.leftMargin + L.cardW/2; const stockY = Math.round(L.h * 0.06) + L.cardH/2; if(Math.hypot(x-stockX, y-stockY) < L.cardW) flipStock(); });

  function canStackOnTableau(upper, lower){ if(!upper) return false; if(!lower) return upper.data.val===13; // King
    const upperColor = (upper.data.s==='hearts' || upper.data.s==='diamonds')? 'red':'black'; const lowerColor = (lower.data.s==='hearts' || lower.data.s==='diamonds')? 'red':'black'; return upper.data.val === lower.data.val - 1 && upperColor !== lowerColor;
  }

  function canMoveToFoundation(cardSprite, foundation){ if(!cardSprite) return false; if(foundation.length===0) return cardSprite.data.val===1; const top = foundation[foundation.length-1]; return top.data.s === cardSprite.data.s && cardSprite.data.val === top.data.val+1; }

  function handleAutoMoveAttempt(sprite){ // try to auto-move single card to foundation
    const loc = findSpriteLocation(sprite); if(!loc) return false; let card = null; if(loc.zone==='waste') card = wasteS[wasteS.length-1]; else if(loc.zone==='tableau'){ const col = tableauS[loc.col]; if(loc.index !== col.length-1) return false; card = col[col.length-1]; } else return false;
    for(let f=0; f<4; f++){ if(canMoveToFoundation(card, foundationS[f])){ commitMoveToFoundation(loc, f, card); layoutAndRender(); return true; } }
    return false;
  }

  function autoMoveToFoundations(){ let moved=false; do{ moved=false; // waste to foundation
    if(wasteS.length){ const wtop = wasteS[wasteS.length-1]; for(let f=0;f<4;f++){ if(canMoveToFoundation(wtop, foundationS[f])){ commitMoveToFoundation({zone:'waste'}, f, wtop); moved=true; break; } } }
    // tableau tops
    for(let c=0;c<7 && !moved;c++){ const col = tableauS[c]; if(!col.length) continue; const top = col[col.length-1]; if(!top.faceUp) continue; for(let f=0;f<4;f++){ if(canMoveToFoundation(top, foundationS[f])){ commitMoveToFoundation({zone:'tableau', col:c, index:col.length-1}, f, top); moved=true; break; } } }
  } while(moved); layoutAndRender(); }

  function pushUndo(){ // store minimal state snapshot
    try{
      const snap = {
        stock: stockS.map(s=>({id:s.data.id, faceUp:s.faceUp})),
        waste: wasteS.map(s=>({id:s.data.id, faceUp:s.faceUp})),
        foundations: foundationS.map(f=>f.map(s=>({id:s.data.id, faceUp:s.faceUp}))),
        tableau: tableauS.map(col=>col.map(s=>({id:s.data.id, faceUp:s.faceUp}))),
        moves, vegasScore
      };
      undoStack.push(snap);
      if(undoStack.length>200) undoStack.shift();
    }catch(e){}
  }

  function restoreFromSnapshot(snap){ // clear and rebuild sprites arrays
    // remove old sprites
    pilesContainer.removeChildren(); stockS=[]; wasteS=[]; foundationS=[[],[],[],[]]; tableauS=[[],[],[],[],[],[],[]];
    // helper to create sprite by id
    function createById(id){ const data = { r: id.split('_')[0], s: id.split('_of_')[1], id, val: rankValueFromId(id) }; const sp = makeCardSprite(data); sp.faceUp = true; updateSprite(sp); pilesContainer.addChild(sp); return sp; }
    // stock
    for(const c of snap.stock){ const sp = createById(c.id); sp.faceUp = c.faceUp; stockS.push(sp); }
    // waste
    for(const c of snap.waste){ const sp = createById(c.id); sp.faceUp = c.faceUp; wasteS.push(sp); }
    // foundations
    for(let f=0;f<4;f++) for(const c of snap.foundations[f]){ const sp = createById(c.id); sp.faceUp = c.faceUp; foundationS[f].push(sp); }
    // tableau
    for(let t=0;t<7;t++) for(const c of snap.tableau[t]){ const sp = createById(c.id); sp.faceUp = c.faceUp; tableauS[t].push(sp); }
    moves = snap.moves; vegasScore = snap.vegasScore || 0; layoutAndRender(); updateMovesDisplay(); }

  function rankValueFromId(id){ const r = id.split('_of_')[0]; return rankNames.indexOf(r)+1; }

  function undo(){ if(!undoStack.length) return; const snap = undoStack.pop(); restoreFromSnapshot(snap); playSound('move'); }

  function updateMovesDisplay(){ movesPill.textContent = `Moves: ${moves}`; if(vegas){ movesPill.textContent += ` | Score: ${vegasScore}`; } }

  function saveState(){ try{ const snap = undoStack[undoStack.length-1]; localStorage.setItem('solitaire_snapshot', JSON.stringify(snap)); }catch(e){} }
  function loadState(){ try{ const s = JSON.parse(localStorage.getItem('solitaire_snapshot')); if(s) restoreFromSnapshot(s); }catch(e){} }

  function checkWinAndCelebrate(){ if(foundationS.flat().length === 52){ // win
      playSound('win'); showWinAnimation(); } }

  function showWinAnimation(){ // simple: shower remaining stage with card sprites
    const L = layout(); for(let i=0;i<40;i++){ const idx = Math.floor(Math.random()*rankNames.length); const sIdx = Math.floor(Math.random()*suits.length); const id = `${rankNames[idx]}_of_${suits[sIdx]}`; const sp = new PIXI.Sprite(loaderPIXI.resources[id].texture); sp.anchor.set(0.5); sp.width = L.cardW*0.6; sp.height = L.cardH*0.6; sp.x = Math.random()*app.renderer.width; sp.y = -50; sp.rotation = (Math.random()-0.5); app.stage.addChild(sp); const duration = 1500 + Math.random()*800; const vx = (Math.random()-0.5)*6; const vy = 3 + Math.random()*6; const rot = (Math.random()-0.5)*0.5; const start = Date.now(); const idAnim = app.ticker.add(()=>{ const t = (Date.now()-start)/duration; sp.x += vx; sp.y += vy; sp.rotation += rot*0.01; if(sp.y > app.renderer.height + 80){ app.stage.removeChild(sp); app.ticker.remove(idAnim); } }); }
  }

  function playSound(kind){ if(muted) return; try{ const ctx = new (window.AudioContext||window.webkitAudioContext)(); const o = ctx.createOscillator(); const g = ctx.createGain(); o.connect(g); g.connect(ctx.destination); if(kind==='move'){ o.frequency.value = 700; g.gain.value = 0.02; } else { o.frequency.value = 880; g.gain.value = 0.03; } o.start(); setTimeout(()=>{ o.stop(); ctx.close(); }, 120); }catch(e){}
  }

  // utilities used in multiple places
  function removeFromArray(arr, item){ const idx = arr.indexOf(item); if(idx>=0) arr.splice(idx,1); }

  // initial hook: periodically relayout on resize
  app.renderer.on('resize', ()=>{ layoutAndRender(); });

  // expose for debugging
  window.klondike = { newGame: startNewDeal, auto: autoMoveToFoundations };

  // initial render call in case resources already present
  // nothing further to do here: startNewDeal will create things after resources loaded
})();
</script>

</body>
</html>
