<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Solitaire ‚Äî Klondike (Google-style)</title>
<style>
:root{
  --bg-top:#e5c1d1; /* keep user's preferred gradient top */
  --bg-bottom:#d3e6f5; /* keep bottom */
  --felt:#0f7a53; /* green felt accent like Google */
  --card:#fff;
  --card-back:#1f3a5f;
  --accent:#12324a;
  --glass: rgba(255,255,255,0.9);
  --card-w: clamp(58px, 11vmin, 106px);
  --card-h: calc(var(--card-w) * 1.4);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0}
body{
  display:flex;align-items:center;justify-content:center;padding:18px;
  background: linear-gradient(180deg,var(--bg-top),var(--bg-bottom));
  font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
}
/* container like Google play */
.app{
  width:min(1200px,98vw);
  max-height:96vh; height:min(820px,94vh);
  background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.75));
  border-radius:18px; padding:18px; display:flex; flex-direction:column; gap:12px; box-shadow:0 20px 50px rgba(0,0,0,.12);
}
.header{
  display:flex;align-items:center;justify-content:space-between;gap:12px;
}
.brand{display:flex;align-items:center;gap:12px}
.logo{width:44px;height:44px;border-radius:12px;background:linear-gradient(145deg,#fff,#ffd1e6);display:grid;place-items:center;font-weight:900;color:var(--accent)}
.controls{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
.btn{background:#fff;border-radius:999px;padding:10px 14px;font-weight:700;border:0;box-shadow:0 8px 20px rgba(0,0,0,.08);cursor:pointer}
.toggle{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;background:#fff;border-radius:999px}
.icon-btn{width:44px;height:44px;border-radius:10px;display:grid;place-items:center;background:#fff;border:0;box-shadow:0 8px 20px rgba(0,0,0,.06);cursor:pointer}
.stats{display:flex;gap:10px;align-items:center}
.pill{background:#fff;padding:8px 12px;border-radius:999px;box-shadow:0 8px 20px rgba(0,0,0,.06);font-weight:800}

/* board */
.board{
  background: linear-gradient(180deg, var(--felt), #0c5f44);
  border-radius:12px;padding:16px;flex:1;display:flex;flex-direction:column;gap:12px;position:relative;overflow:hidden;
}
.topRow{display:flex;gap:12px;align-items:flex-start}
.leftGroup{display:flex;gap:12px}
.pile{width:var(--card-w);min-height:var(--card-h);border-radius:12px;background:rgba(255,255,255,0.06);display:grid;place-items:center;position:relative}
.placeholder{width:var(--card-w);height:var(--card-h);border-radius:10px;border:2px dashed rgba(255,255,255,0.12);display:grid;place-items:center;color:rgba(255,255,255,0.38);font-weight:700}
.foundations{margin-left:auto;display:flex;gap:12px}
.tableau{display:grid;grid-template-columns:repeat(7,1fr);gap:12px;padding-top:6px;flex:1;overflow:auto}
.tableau .pile{min-height:calc(var(--card-h) + 240px);background:transparent}

/* Card */
.card{width:var(--card-w);height:var(--card-h);border-radius:12px;background:var(--card);position:absolute;left:50%;transform:translateX(-50%);box-shadow:0 12px 28px rgba(0,0,0,.28);display:flex;flex-direction:column;justify-content:space-between;padding:10px;color:#111;transition:box-shadow .12s, transform .12s}
.card.face-down{background:linear-gradient(180deg,#2c3e50,#1b2b38);color:#fff}
.card .corner{font-weight:900;font-size:clamp(12px,2.2vmin,18px)}
.card .pips{font-size:clamp(18px,4vmin,34px);text-align:center;align-self:center}
.card.red{color:#e12a3a}
.card.black{color:#111}
.card.dragging{opacity:.95;filter:drop-shadow(0 30px 40px rgba(0,0,0,.45))}

.drop-ok{box-shadow:0 0 0 4px rgba(255,255,255,0.12) inset,0 18px 36px rgba(0,0,0,.4)}
.hint{outline:3px solid #ffd166;outline-offset:4px}

.win{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
.win .badge{background:rgba(255,255,255,0.96);padding:18px 28px;border-radius:12px;font-weight:900;color:var(--accent);box-shadow:0 20px 46px rgba(0,0,0,.18)}

.modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.36)}
.modal .card{position:static;transform:none}

/* small screens */
@media (max-width:820px){ .stats{display:none} .app{padding:12px} }
@media (max-width:520px){ :root{--card-w:64px; --card-h: calc(var(--card-w)*1.42)} .controls .btn{padding:8px 10px} }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Google-style Solitaire">
    <div class="header">
      <div class="brand"><div class="logo">K</div><div style="font-weight:800;color:var(--accent)">Solitaire</div></div>
      <div style="display:flex;align-items:center;gap:12px">
        <div class="controls" role="toolbar">
          <button class="btn" id="newBtn">New</button>
          <button class="btn" id="undoBtn">Undo</button>
          <button class="btn" id="autoBtn">Auto</button>
          <label class="toggle"><input type="checkbox" id="drawChk" style="transform:scale(1.1)" /> Draw 3</label>
          <button class="btn" id="hintBtn">Hint</button>
          <button class="icon-btn" id="helpBtn">‚ùî</button>
        </div>
        <div class="stats">
          <div class="pill" id="moves">Moves: 0</div>
          <div class="pill" id="time">Time: 00:00</div>
        </div>
      </div>
    </div>

    <div class="board" id="board">
      <div class="topRow">
        <div class="leftGroup">
          <div class="pile" id="stock"></div>
          <div class="pile" id="waste"></div>
        </div>
        <div class="foundations">
          <div class="pile" id="f0"></div>
          <div class="pile" id="f1"></div>
          <div class="pile" id="f2"></div>
          <div class="pile" id="f3"></div>
        </div>
      </div>

      <div class="tableau" id="tableau">
        <div class="pile" id="t0"></div>
        <div class="pile" id="t1"></div>
        <div class="pile" id="t2"></div>
        <div class="pile" id="t3"></div>
        <div class="pile" id="t4"></div>
        <div class="pile" id="t5"></div>
        <div class="pile" id="t6"></div>
      </div>

      <div class="win" id="win" aria-hidden="true"><div class="badge">üéâ You Win!</div></div>
    </div>
  </div>

  <div class="modal" id="modal" aria-hidden="true">
    <div style="background:#fff;padding:18px;border-radius:10px;max-width:520px">
      <div style="display:flex;justify-content:space-between;align-items:center"><h3 style="margin:0">How to play</h3><button id="closeModal" class="btn">Close</button></div>
      <p style="color:#333">Move all cards to the foundations by suit from Ace to King. Build tableau columns down in alternating colors. Tap the stock to draw cards. Drag or double-tap cards to move quickly.</p>
    </div>
  </div>

<script>
// Google-style Klondike Solitaire ‚Äî self contained, no external assets
document.addEventListener('DOMContentLoaded', ()=>{
  const SUITS = ['‚ô†','‚ô•','‚ô¶','‚ô£'];
  const COLORS = { '‚ô†':'black','‚ô£':'black','‚ô•':'red','‚ô¶':'red' };
  const RANKS = [null,'A','2','3','4','5','6','7','8','9','10','J','Q','K'];

  const qs = id => document.getElementById(id);
  const piles = {
    stock: qs('stock'), waste: qs('waste'),
    f: [qs('f0'), qs('f1'), qs('f2'), qs('f3')],
    t: [qs('t0'),qs('t1'),qs('t2'),qs('t3'),qs('t4'),qs('t5'),qs('t6')]
  };

  const ui = {
    newBtn: qs('newBtn'), undoBtn: qs('undoBtn'), autoBtn: qs('autoBtn'), drawChk: qs('drawChk'), hintBtn: qs('hintBtn'),
    moves: qs('moves'), time: qs('time'), win: qs('win'), helpBtn: qs('helpBtn'), modal: qs('modal'), closeModal: qs('closeModal')
  };

  let state = null, undoStack = [], timer = null, startTs = 0, lastTap = 0;

  function makeDeck(){ const d=[]; for(const s of SUITS) for(let r=1;r<=13;r++) d.push({s,r,id:s+':'+r}); return d; }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

  function newGame(){
    const deck = makeDeck(); shuffle(deck);
    const t=[[],[],[],[],[],[],[]];
    for(let c=0;c<7;c++) for(let i=0;i<=c;i++){ const card = deck.pop(); card.faceUp = (i===c); t[c].push(card); }
    state = { stock: deck.map(d=>({...d,faceUp:false})), waste:[], f:[[],[],[],[]], t, moves:0, draw3:ui.drawChk.checked };
    undoStack = [];
    startTimer();
    animateDealAndRender();
  }

  function clone(o){ return JSON.parse(JSON.stringify(o)); }
  function pushUndo(){ undoStack.push(clone(state)); if(undoStack.length>400) undoStack.shift(); }
  function undo(){ if(undoStack.length){ state = undoStack.pop(); render(); } }

  function startTimer(){ startTs = Date.now(); if(timer) clearInterval(timer); timer = setInterval(updateHUD,1000); }
  function updateHUD(){ ui.moves.textContent = 'Moves: '+state.moves; const s = Math.floor((Date.now()-startTs)/1000); const mm = String(Math.floor(s/60)).padStart(2,'0'); const ss = String(s%60).padStart(2,'0'); ui.time.textContent = `Time: ${mm}:${ss}`; }

  function cardEl(card){
    const d = document.createElement('div'); d.className = 'card '+(card.faceUp? 'face-up ':'face-down ')+(COLORS[card.s]==='red'?'red':'black');
    d.dataset.id = card.id; d.dataset.r = card.r; d.dataset.s = card.s;
    d.innerHTML = `<div class="corner top"><div class="rank">${RANKS[card.r]}</div><div class="suit">${card.s}</div></div><div class="pips">${card.faceUp?card.s:''}</div><div class="corner bottom"><div class="rank">${RANKS[card.r]}</div><div class="suit">${card.s}</div></div>`;
    d.style.transition = 'transform .18s ease, top .18s ease, left .18s ease, box-shadow .12s';
    return d;
  }

  function clearAll(){ [piles.stock,piles.waste,...piles.f,...piles.t].forEach(p=>p.innerHTML=''); }

  function render(skipHUD){
    clearAll();
    // stock
    if(state.stock.length){ const top = state.stock[state.stock.length-1]; const el = cardEl({...top,faceUp:false}); el.style.position='relative'; el.style.left='50%'; el.style.transform='translateX(-50%)'; piles.stock.appendChild(el); } else piles.stock.appendChild(placeholder());
    // waste
    if(state.waste.length){ const w = state.waste[state.waste.length-1]; const el = cardEl(w); el.style.position='relative'; el.style.left='50%'; el.style.transform='translateX(-50%)'; piles.waste.appendChild(el);} else piles.waste.appendChild(placeholder());
    // foundations
    for(let i=0;i<4;i++){ const f = state.f[i]; if(f.length){ const top = f[f.length-1]; const el = cardEl(top); el.style.position='relative'; el.style.left='50%'; el.style.transform='translateX(-50%)'; piles.f[i].appendChild(el); } else piles.f[i].appendChild(placeholder()); }
    // tableau
    for(let c=0;c<7;c++){ const col = state.t[c]; const pile = piles.t[c]; if(col.length===0){ pile.appendChild(placeholder()); continue;} let y=8; const overlapFace = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-h'))||140; for(let k=0;k<col.length;k++){ const card = col[k]; const el = cardEl(card); el.style.position='absolute'; el.style.top = y+'px'; el.style.zIndex = k+1; pile.appendChild(el); y += card.faceUp? Math.max(24, Math.round(parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-h'))*0.18)) : 18; } }
    if(!skipHUD) updateHUD(); attachInteractions(); saveState(); ui.win.style.display = checkWin()? 'block':'none';
  }

  function placeholder(){ const p = document.createElement('div'); p.className='placeholder'; return p; }

  function canStackOnTableau(upper, lower){ if(!upper) return false; if(!lower) return upper.r===13; return (COLORS[upper.s] !== COLORS[lower.s]) && upper.r === lower.r - 1; }
  function canMoveToFoundation(card, foundation){ if(!card) return false; if(foundation.length===0) return card.r===1; const top = foundation[foundation.length-1]; return top.s === card.s && card.r === top.r + 1; }
  function fromId(id){ for(let i=0;i<7;i++){ const col=state.t[i]; for(let k=0;k<col.length;k++) if(col[k].id===id) return {zone:'t', i, k}; } for(let i=0;i<4;i++){ const f=state.f[i]; for(let k=0;k<f.length;k++) if(f[k].id===id) return {zone:'f', i, k}; } for(let k=0;k<state.waste.length;k++) if(state.waste[k].id===id) return {zone:'waste', k}; for(let k=0;k<state.stock.length;k++) if(state.stock[k].id===id) return {zone:'stock', k}; return null; }

  function flipTopIfNeeded(col){ if(col.length && !col[col.length-1].faceUp) col[col.length-1].faceUp = true; }

  // animate dealing to tableau for a Google-like feel then render fully interactive
  function animateDealAndRender(){
    clearAll(); // show stock back briefly
    const deck = [];
    for(const c of state.stock) deck.push({...c});
    for(let i=0;i<7;i++) for(const c of state.t[i]) deck.push({...c});
    // simple card backs flying from top-left of board to piles
    const boardRect = qs('board').getBoundingClientRect();
    const sourceX = boardRect.left + 30, sourceY = boardRect.top + 20;
    let idx=0;
    const placed = [];
    function placeNext(){
      if(idx >= deck.length){ render(); return; }
      const card = deck[idx++];
      const ghost = cardEl({...card, faceUp:false}); ghost.style.position='fixed'; ghost.style.left = sourceX+'px'; ghost.style.top = sourceY+'px'; ghost.style.transform = 'translate(0,0) scale(.98)'; document.body.appendChild(ghost);
      // compute destination
      let destEl = null;
      // first portion are the tableau cards in order
      const tableauCount = state.t.reduce((acc,col)=>acc+col.length,0);
      const tgt = document.querySelectorAll('.tableau .pile')[ (idx-1) % 7 ];
      if(tgt) destEl = tgt.getBoundingClientRect(); else destEl = { left: boardRect.left + 20 + ((idx%7)*100), top: boardRect.top + 140 };
      // animate
      requestAnimationFrame(()=>{ ghost.style.transition = 'transform .42s cubic-bezier(.2,.9,.2,1), left .42s, top .42s'; ghost.style.left = (destEl.left + (destEl.width/2) - ghost.offsetWidth/2) + 'px'; ghost.style.top = (destEl.top + 20) + 'px'; ghost.style.transform = 'translate(0,0) scale(1)'; setTimeout(()=>{ ghost.remove(); placeNext(); }, 160); });
    }
    placeNext();
  }

  // interactions: click stock, double-tap, drag & drop
  piles.stock.addEventListener('click', ()=>{
    pushUndo(); const take = state.draw3?3:1; let moved=0; while(state.stock.length && moved<take){ state.waste.push({...state.stock.pop(), faceUp:true}); moved++; } if(!moved){ while(state.waste.length) state.stock.push({...state.waste.pop(), faceUp:false}); } else state.moves++; render();
  });

  function isDoubleTap(){ const now=Date.now(); const ok=(now-lastTap)<320; lastTap=now; return ok; }

  function tryAutoToFoundation(cardId){ const loc = fromId(cardId); if(!loc) return false; let card; if(loc.zone==='waste') card = state.waste[state.waste.length-1]; else if(loc.zone==='t'){ const col = state.t[loc.i]; if(loc.k !== col.length-1) return false; card = col[col.length-1]; } else return false; for(let i=0;i<4;i++){ if(canMoveToFoundation(card, state.f[i])){ pushUndo(); if(loc.zone==='waste') state.waste.pop(); else state.t[loc.i].pop(), flipTopIfNeeded(state.t[loc.i]); state.f[i].push(card); state.moves++; render(); return true; } } return false; }

  function hint(){ clearHints(); const add=(el)=>{ el.classList.add('hint'); setTimeout(()=>el.classList.remove('hint'),900); };
    const w = state.waste[state.waste.length-1]; if(w){ for(let i=0;i<4;i++) if(canMoveToFoundation(w,state.f[i])){ add(piles.f[i]); return; } for(let i=0;i<7;i++){ const targ = state.t[i].length? state.t[i][state.t[i].length-1] : null; if(canStackOnTableau(w,targ)){ add(piles.t[i]); return; } } }
    for(let c=0;c<7;c++){ const col = state.t[c]; const top = col[col.length-1]; if(!top||!top.faceUp) continue; for(let i=0;i<4;i++) if(canMoveToFoundation(top,state.f[i])){ add(piles.f[i]); return; } for(let i=0;i<7;i++){ if(i===c) continue; const targ = state.t[i].length? state.t[i][state.t[i].length-1] : null; if(canStackOnTableau(top,targ)){ add(piles.t[i]); return; } } }
    piles.stock.classList.add('hint'); setTimeout(()=>piles.stock.classList.remove('hint'),700);
  }

  function clearHints(){ document.querySelectorAll('.hint').forEach(x=>x.classList.remove('hint')); }

  function autoMove(){ let cont; do{ cont=false; if(state.waste.length){ const wtop = state.waste[state.waste.length-1]; for(let i=0;i<4;i++) if(canMoveToFoundation(wtop,state.f[i])){ pushUndo(); state.f[i].push(state.waste.pop()); state.moves++; cont=true; break; } } for(let t=0;t<7 && !cont;t++){ const col = state.t[t]; if(!col.length) continue; const top = col[col.length-1]; if(!top.faceUp) continue; for(let i=0;i<4;i++) if(canMoveToFoundation(top,state.f[i])){ pushUndo(); state.f[i].push(col.pop()); flipTopIfNeeded(col); state.moves++; cont=true; break; } } }while(cont); render(); }

  // Drag & Drop
  let drag = { active:false };
  function attachInteractions(){
    document.querySelectorAll('.card.face-up').forEach(c=>{
      c.onpointerdown = startDrag;
      c.onclick = (e)=>{ if(isDoubleTap()) tryAutoToFoundation(c.dataset.id); };
    });
    piles.waste.onclick = ()=>{ const t = state.waste[state.waste.length-1]; if(t) tryAutoToFoundation(t.id); };
  }

  function startDrag(e){
    if(e.button && e.button !== 0) return; // only left click/touch
    const id = e.currentTarget.dataset.id; const loc = fromId(id); if(!loc) return; let stack=[];
    if(loc.zone==='t'){ const col = state.t[loc.i]; if(!col[loc.k].faceUp) return; stack = col.slice(loc.k); }
    else if(loc.zone==='waste'){ if(loc.k !== state.waste.length-1) return; stack = [state.waste[loc.k]]; }
    else return;

    drag = { active:true, from:loc, stack:clone(stack), ghost: buildGhost(stack, e.clientX, e.clientY) };
    document.body.appendChild(drag.ghost);
    document.addEventListener('pointermove', onDragMove);
    document.addEventListener('pointerup', onDragEnd, { once:true });
  }

  function buildGhost(stack,x,y){ const wrap=document.createElement('div'); wrap.style.position='fixed'; wrap.style.left='0'; wrap.style.top='0'; wrap.style.zIndex=9999; wrap.style.pointerEvents='none'; let top=0; for(const c of stack){ const el = cardEl(c); el.style.position='absolute'; el.style.left='0'; el.style.top=top+'px'; el.style.transform='none'; el.style.boxShadow='0 30px 60px rgba(0,0,0,.5)'; wrap.appendChild(el); top += 22; } wrap.style.transform = `translate(${x-40}px, ${y-60}px)`; return wrap; }

  function onDragMove(e){ if(!drag.active) return; drag.ghost.style.transform = `translate(${e.clientX-40}px, ${e.clientY-60}px)`; highlightDrops(drag.stack,e.clientX,e.clientY); }

  function highlightDrops(stack,x,y){ clearDropHighlights(); for(let i=0;i<4;i++){ if(stack.length===1 && canMoveToFoundation(stack[0],state.f[i])) piles.f[i].classList.add('drop-ok'); } for(let i=0;i<7;i++){ const col = state.t[i]; const targ = col.length? col[col.length-1] : null; if(canStackOnTableau(stack[0],targ)) piles.t[i].classList.add('drop-ok'); } }
  function clearDropHighlights(){ document.querySelectorAll('.drop-ok').forEach(e=>e.classList.remove('drop-ok')); }

  function findDropTarget(x,y){ const els = [...piles.f,...piles.t]; for(const p of els){ const r = p.getBoundingClientRect(); if(x>=r.left && x<=r.right && y>=r.top && y<=r.bottom) return p; } return null; }

  function onDragEnd(e){ document.removeEventListener('pointermove', onDragMove); clearDropHighlights(); if(!drag.active) return; drag.active=false; if(drag.ghost && drag.ghost.parentNode) drag.ghost.parentNode.removeChild(drag.ghost); const target = findDropTarget(e.clientX,e.clientY); if(!target) return; const moving = drag.stack; // determine if foundation
    const isFoundation = Array.from(piles.f).includes(target);
    if(isFoundation){ const idx = Array.from(piles.f).indexOf(target); if(idx>=0 && moving.length===1 && canMoveToFoundation(moving[0],state.f[idx])){ pushUndo(); removeFromSource(drag.from,moving.length); state.f[idx].push(moving[0]); state.moves++; postMoveCleanup(); render(); } return; }
    // tableau
    const tIdx = Array.from(piles.t).indexOf(target);
    if(tIdx>=0){ const col = state.t[tIdx]; const lower = col.length? col[col.length-1] : null; if(canStackOnTableau(moving[0], lower)){ pushUndo(); removeFromSource(drag.from,moving.length); for(const c of moving) col.push(c); state.moves++; postMoveCleanup(); render(); } }
  }

  function removeFromSource(from,count){ if(from.zone==='waste') state.waste.splice(state.waste.length-count,count); else if(from.zone==='t') state.t[from.i].splice(from.k,count), flipTopIfNeeded(state.t[from.i]); }

  function postMoveCleanup(){ if(checkWin()) ui.win.style.display = 'block'; }
  function checkWin(){ return state.f.every(f=>f.length===13); }

  // controls
  ui.newBtn.addEventListener('click', newGame);
  ui.undoBtn.addEventListener('click', undo);
  ui.autoBtn.addEventListener('click', autoMove);
  ui.hintBtn.addEventListener('click', hint);
  ui.drawChk.addEventListener('change', ()=> { if(state) state.draw3 = ui.drawChk.checked; });

  ui.helpBtn.addEventListener('click', ()=>{ ui.modal.style.display='flex'; ui.modal.setAttribute('aria-hidden','false'); });
  ui.closeModal.addEventListener('click', ()=>{ ui.modal.style.display='none'; ui.modal.setAttribute('aria-hidden','true'); });

  // stock double-click handling
  piles.waste.addEventListener('dblclick', ()=>{ const top = state.waste[state.waste.length-1]; if(top) tryAutoToFoundation(top.id); });

  function hint(){ /* implemented above */ hint(); }

  // persistence
  function saveState(){ try{ localStorage.setItem('solitaire_state', JSON.stringify(state)); localStorage.setItem('solitaire_draw3', state.draw3?'1':'0'); }catch(e){} }
  function loadState(){ try{ const s = JSON.parse(localStorage.getItem('solitaire_state')); if(s){ state=s; ui.drawChk.checked = localStorage.getItem('solitaire_draw3')==='1'; state.draw3 = ui.drawChk.checked; startTimer(); render(); return true; } }catch(e){} return false; }

  function trySave(){ saveState(); }

  // save on unload
  window.addEventListener('beforeunload', trySave);

  // init
  if(!loadState()) newGame(); else render();

});
</script>
</body>
</html>
